## 一些传统池水

### 大小写

project name一般全小写，这是延续了unix的传统，因为在那里面一般只有很重要很惊慌的事情才大写

classname一般是每个单词的第一个字母大写

### 头文件 源文件

**(自动售票机)**老师在ticketmachine里创建了三个文件 后缀<img src="https://s1.imagehub.cc/images/2024/11/24/309c0ac4e2550cef9d150e5e1dad0402.png" alt="image 20220121224059806" style="zoom:67%;" />

文件类型分别是project，class，source file（源文件）

里面写的东西分别是class里的函数 ，类（public,private/protected），主控制流（main）

**看后缀名可以知道，第2个文件是头文件，其余两个是源文件**

image-20220122112224419.png

（所以编译器要求使用之前必须声明）

<img src="https://s1.imagehub.cc/images/2024/11/24/e7dea58525130fe3bdf6d778ef480bd7.png" alt="image 20220122111809093" style="zoom:67%;" />

<img src="https://s1.imagehub.cc/images/2024/11/24/f8c4d80e64ecba61a0a877750c7a8a0d.png" alt="image 20220122111927586" style="zoom:67%;" />

<img src="https://s1.imagehub.cc/images/2024/11/24/d67fc7d83a6e79b0473dcf5c334d8b22.png" alt="image 20220122112025270" style="zoom:67%;" />

<img src="https://s1.imagehub.cc/images/2024/11/24/b8b7947c5876e9774193431e7f0af778.png" alt="image 20220123111502308" style="zoom:67%;" />

### 编译汇编

<img src="https://s1.imagehub.cc/images/2024/11/24/674216e53aaf32ebc9e2bec0716c776a.png" alt="image 20220123115707847" style="zoom:67%;" />



# 单元导读

1. 成员函数是属于类的，成员变量是属于对象的。

   对象去调取类的

2. 

3. 

4. 

5. 

6. 成员函数是属于类的，成员变量是属于对象的。

   对象去调取函数时，尽管函数属于类，但函数仍旧能分清是哪个对象调用它，并且接收的是属于对象里的成员变量的地址

   还有**this**的浅浅介绍

7. 构造函数（用于自动为对象初始化）；析构函数

8. 这一节讲了如何用构造函数进行初始化

9. 了解delete和析构的区别，这非常重要。析构的类型是由对象决定的，而对象要出作用域的时候，也就是要调用析构函数的时候，析构只是清空内存上的数据，而delete是回收这片内存。（delete回收多少内存与析构无关，由表格记录决定，所以无论加不加方括号，delete都会回收整片对象的内存，而加不加方括号对于析构函数来说有影响，加了的话就会析构整片对象的内存，但不加的话就只会析构第1个对象的内存）并且我们会由对象类型先确定析构类型，然后析构，然后查表，然后回收内存。

10. 类的对象之间可以访问私有成员变量，private是对类来说的， 你们是同一个类就行。

    还有**friend**的浅浅介绍

    *还有编译、提前声明、struct&class区别一些杂七杂八的*

11. 所有的类的成员变量在初始化的时候都建议用列表初始化(list initialization)，列表初始化会在构造函数之前被调用

    列表初始化可以是构造函数（这样的话就需要额外的一个构造函数default constructor），也可以是具体的值

12. 对于类的成员变量1是另一个类的对象2构成的这件事，尽管对象2是在成员变量1里面被生成的，但如果对象2生成的时候是在1的类的private里面，那么即使是类1也只能访问对象2的public部分

    **要注意在类1里面的构造函数上，一定要对2进行列表初始化**

13. 继承是子类继承父类，可以继承父类的成员函数，成员数据，接口。

    但这不意味着子类的对象也可以随意访问private里面的东西，当然了，public里面的东西还是可以直接访问的。

    子类虽然继承到父类的private部分，但是不能直接访问，还是要通过父类的成员函数才能访问。

    **protected:**如果你在父类里面把一个东西的属性定义为 protected，那么这个东西只有自己这个类和子类能用。但是这个东西只有在子类的成员函数中才可以用，连在main函数中都不可以。（哪怕你在main函数中通过子类的对象调用子类的成员函数都不可以）

14. 首先学习了函数重载是什么
    其次知道了即使子类继承了父类的一切，但是当子类的对象想要传出始值的时候，(虽然子类的对象一生成，父类的构造函数就会被调用。但是不代表你能合理的给他传入初始值)想要和你的传入初始值，必须对子类的构造函数进行改造。也就是在子类的构造函数中加入初始化列表(具体的跳转至相应单元看)
    这里面还对应了两个知识点，第一是列表初始化的顺序。第二是析构的顺序。

    其次，一个比较关键的事，如父类拥有重载的函数，而子类也声明了一个和父类名字相同，参数相同的函数，那么父类所有与子类名字相同的函数都会被隐藏掉。

15. 

16. 这一节看上去内容很多，但实际上并不需要了解那么多。inline实际上就是把一个函数的body插到要调用他的位置。
    在一个函数前面加上inline是声明。所以可以放在头文件里写，而且我们最好全都放在头文件里。
    在本节我们还讲了什么样的inline写法是错误的？正确的inline写法，还有在头文件里面怎么加入inline？以及什么情况下写程序的人可以使用inline?

17. const是编译时常量（而非运行时常量）

18. 

19. 

20. 指针和引用才能构成upcase

21. 讲了**virtual**

    指针和引用才能构成多态性

22. 

23. 综合了引用和const

24. 

25. 

26. 

27. 地点



## 1.对象

在程序设计中，对象就是变量（变量是对象的形式载体） 

<img src="https://s1.imagehub.cc/images/2024/11/24/56b6780b6bd0e0f2a0b33c5b007fca38.png" alt="image 20220121165354451" style="zoom:80%;" />

功能可以被认为是接口，通过接口和属性进行沟通。

### 面向过程与面向对象

拿上课举例**面向过程**是描述成同学走进教室，老师走进教室，上课影响老师上课，下课铃响，老师下课。

**面向对象：**首先分析有哪些对象：老师，同学，投影仪...然后描述对象之间的关系以及对象的操作，比如老师讲课通过声音被同学听到。

### C和C++程序对比

<img src="https://s1.imagehub.cc/images/2024/11/24/35126c66f265a79c0e3063bac2ad6d5d.png" alt="image 20220121165626152" style="zoom:50%;" />

C版本的 Struct和C++里面的class是一样的，具体的不一样可以不用纠结。

在C语言的struct里面，对于对象，point3d的操作print在 Struct外面，也就是最后一行，你需要把对象的地址传入一个打印函数，才能对point3d进行操作。

在C++的 Class里，既有对于对象的数据描述(xyz)，也有对于对象的操作描述。所以对象可以自己做操作，比如最后一行，

### 面向对象

面向对象是一种方法，用来组织，设计和实现。

设计指的是根据问题来设计算法，有了面向对象就有了面向对象的思想，就可以用来做设计。

实线指的是有了面向对象，你就可以用使用面向对象的语言来实现想要的程序。



## 2.面向对象基本原理

对象和对象之间交互的形式是 消息

消息是：

* 由发送方组成
* 但是消息做不做，实现不实现，由**接收方**决定
* 消息传递的方式是函数

第二点提醒我们，每一次你作为发送方在发消息的时候，一定要考虑到接收方会不会做这个消息（这里的会不会做指的是接收方，有没有这个功能，只要有功能他就会做这个）

举例子：比如说老师让同学站起来，老师是发送消息的一方，消息是站起来。同学是接收消息的一方，那么同学可以选择站也可以选择不站，这是因为尽管我们作为一个人我们是可以不站的，但是，如果同学作为对象提供了这样的服务，那么他就必须要履行自己的服务。（假使说在这个班里面，同学作为对象都必须提供站起来这个服务，那么老师无论对谁发送信号，另一方都必须履行他的服务，所以我们只要考虑接收方有没有这个功能即可。）

另一种强制让接收方接收消息的方法就是直接去触碰到接收方的内部，让他不得不接受消息（如果你有一些电流可以控制这个同学的肌肉，那么你对他发送站起来，无论他的大脑想不想站起来，那么利用这个机器，都可以让这个同学的肌肉收缩，从而达到站起来）

消息的性质：

* 消息会使接收方改变他的状态

* 消息可能会带来回应（这里的回应是指发送方给接收方发送一个消息，接收方也给发送方发送一个消息。

  但事实上，一般我们不希望这么做，我们只希望消息单方面发送即可。那么你怎么知道自己的消息有没有起到作用呢？有没有被接收方接收呢？这时候你直接读取接收方的状态即可。）

  （拿同学的例子来讲，老师先发出消息让同学站起来，老师并不需要同学回复他说，我站了或者我没站，至于同学有没有站起来，老师的眼睛会发出信息来看if同学站了起来）

  在程序里面，我们一般函数会有一个返回值，所以这也算一种反馈给了发送方。

### Object与Class

 Object是东西， Class是东西的种类。（对东西进行归纳总结，归并成类）

Class是种概念， Object是一种实体.

类定义了对象长什么样,对象是类的一个实例.

### OOP的定义（面向对象程序设计）

*  Everything is 对象 

* 通过发送消息互相告诉对方做什么 的一堆对象 就是程序（就像C语言从main开始互相调，最后程序结束）

  （这个做什么指的是what to do，就好比你找服务员，你只是让他给你倒杯水，你并没有教他去哪里倒什么水，往什么杯子倒）

* 对象的组成还是对象。（在物理空间上对象占用内存）（当然也没让你一直拆对象，拆啊拆，拆到bit，拆到Int即可）

* 先有类型，后有对象（虽然和我们现实中不太一样）

* 一个特定类型的所有对象 可以接收相同的消息（所有的杯子都能装水 所有的灯都能亮）（**我个人认为可以接收相同消息对象提供的服务相同，只有具有这个服务，才能接收这个消息）

  *所有可以接收相同消息的对象 可以被认为是 一个类型*

  由于功能相同的对象，所以对外接口相同的对象也可以被认为是一个类型，毕竟功能它对外提供的就是接口。

接口的好处：当你做的东西遵循接口的要求，那么符合接口的产品都可以往上接（你想想灯的螺旋接口，只要符合接口，那安什么颜色的灯都可以）

<img src="https://s1.imagehub.cc/images/2024/11/24/663ab5d080d9dd70bb638f4ba97e8d09.png" alt="image 20220121211029509" style="zoom:33%;" />



程序里如果是有接口的，那就意味着可以换东西。（否则更换很麻烦）

所以换东西很方便



## 3.自动售票机

### ::解析符resolver

<img src="https://s1.imagehub.cc/images/2024/11/24/5c0978715aa2606d175ec0b6454facb0.png" alt="image 20220121224938311" style="zoom:50%;" />



<img src="https://s1.imagehub.cc/images/2024/11/24/45215015269fdafcf00b8514d8d04254.png" alt="image 20220121224954333" style="zoom:50%;" />

​	

这样说明f()这个函数是羁绊于s的，它是属于S这个类的

如果这么写 void ::f() 那么说明f()是全局的函数

假如类和全局都有一个变量a，那么你写::a--，指的是你要用全局的a。不加冒号a--，指的是直接用类里的成员a（我也不是很清楚 难道不是写s::a--吗）

<img src="https://s1.imagehub.cc/images/2024/11/24/0750298c7ff46a35ef0bb1d3ac3f9128.png" alt="image 20220121230201714" style="zoom:67%;" />

### class的分离

<img src="https://s1.imagehub.cc/images/2024/11/24/adfb0da4fbe46fd8552e7670b649ebbc.png" alt="image 20220122104815363" style="zoom:50%;" />

* 类的声明和原型放在头文件（.h）
* 所有的函数的body放在源文件

## declaration(声明)&definition(定义)

<img src="https://s1.imagehub.cc/images/2024/11/24/2dcb0bd0249b4d3ecf21b4e8bffde1fd.png" alt="image 20220122105654683" style="zoom:50%;" />

* 如果一个函数，是在头文件声明的，那么你必须在这个函数被调用的时候，以及函数被定义实体的时候，去include头文件
* 如果一个类在头文件被声明你必须，在这个类，被使用的时候以及类的成员被定义的时候，去include头文件

<img src="https://s1.imagehub.cc/images/2024/11/24/3f55f9ee50d8029da55c161de4f4de36.png" alt="image 20220122112332531" style="zoom:50%;" />

### 理解#include

#include 是 编译预处理指令。	

在编译器编译之前，实际上还有一个编译预处理器，只有等这个预处理器处理完之后，他才会交给编译器编译。

**include通俗一点解释就是，他可以直接把 Include这个单词后面跟的文件插入到你写了include这个位置的后面**

<img src="https://s1.imagehub.cc/images/2024/11/24/b5ff27ec94846412a910a0d741ae3785.png" alt="image 20220122132355063" style="zoom:50%;" />

* #include"xx.h"他会直接到当前的目录去查找，当前目录指的是写了 Include文件所在的目录
* #include<xx.h>他会直接到系统目录去找

所以include，不太在意后缀，因为只要把文件插入即可，只要你的双引号或尖括号里面是个文件即可。（ Include负责插入就行，至于这个文件合不合理，适不适合这个编译平台，就是编译器去鉴别的事情了，）

现在我们有这样一个文件

```C++
//后缀是.h 是头文件
void f();
int global;
```



```C++
//后缀是.cpp 是源文件
#include "a.h"

int main(){
    return 0;
}
```

当你编译的时候首先编译预处理器发挥作用，它的作用就是把头文件和源文件合在一起，组成一个大的文本，那么怎么组合在一起呢？通过include，(在include里面，我们把头文件include加进来了)所以我们现在可以很方便的直接把他们两个（头文件和源文件）组合在一起。

---

现在是第二种情况

<img src="https://s1.imagehub.cc/images/2024/11/24/08f725b2958875262a0d7c72e2d741d1.png" alt="image 20220122125827404" style="zoom:50%;" />



现在有两个源文件，他们都想用一个头文件，那么编译的时候，会发生什么呢？

现在先不用太理解声明和定义的具体形式，一会我会举例子，现在要知道的是，

头文件中只能放声明，不可以放定义，（否则多个文件用头文件的时候，并且多个文件里需要用头文件里声明的变量的时候，会出错）

![image 20220122131328830](https://s1.imagehub.cc/images/2024/11/24/92b8bc087fa5fee5c1b9b8bf23177c1b.png)

如果你在头文件里面放了定义，或者你在头文件里面放声明，但没有在源文件里面初始化，编译是可以通过的，因为编译它是一个比较粗糙的过程，（不过编译可能会有小     小的提示，会显示出来，但是他不像Error那样，不解决就不给通过，所以下次如果有小小的提示，也可以多看一看它，可能是一个隐藏的错误）

### 声明和定义的进一步解释

首先声明是绝对不会给分配内存空间的，只有定义才会。

并且不是说只有赋值了的才叫定义。

int a；就是定义，它现在已经告诉内存说，需要开辟一个大小为int的空间，并且这个空间叫做a。那么系统可能给分配了一个确实不需要用的空间，但是这个空间里面可能原本就有一些值，所以如果你只是这样定义而不初始化是很危险的，尽管a确实有一个空间，但是它里面的只可能是一些垃圾值。

声明的例子：extern int a；只要前面加入这个单词，那么就是一个声明

<img src="https://s1.imagehub.cc/images/2024/11/24/1c5cf12f39ab6a94c98f8d4dcb2c6171.png" alt="image 20220122132010395" style="zoom:33%;" />

* extern 变量是声明
* 函数原型是声明（如果函数后面有大括号的便是定义，没有大括号的便是声明）
* class/struct声明是声明

## 4.时钟

<img src="https://s1.imagehub.cc/images/2024/11/24/83938d3d34256ccc1f486bf00d0461aa.png" alt="image 20220123114546394" style="zoom:50%;" />

## 5.成员变量

本地变量：在一个函数内部定义的变量。生命周期是函数执行过程。

假如本地变量， C++里面会采取 最近的 距离这个变量定义的地方。

成员变量：定义了一个类,在这个类里面定义的变量就叫成员变量，定义的函数就叫成员函数。



* field 成员变量
* parameters 函数参数
* local variable 本地变量
  * 这三种变量都可以储存值
  * 成员变量定义在函数和构造函数之外
  * *成员变量的值在对象的生存期里是永远存在的*（对象存在它存在）
  * **在定义成员变量的类里，这个类里的所有函数都可以直接使用成员变量（本地变量是只能在那个函数里使用）**

<img src="https://s1.imagehub.cc/images/2024/11/24/15fc425b5a7d94205b1f7ac18922d52d.png" alt="image 20220125103909834" style="zoom:67%;" />

<img src="https://s1.imagehub.cc/images/2024/11/24/c0d9567b621dc6a3d213b3516985e0cd.png" alt="image 20220125103923787" style="zoom:67%;" />

在第1张图里面我们写的是头文件，第2张图我们写的是源文件，不是很懂的，可以看左边大纲的第2个头文件源文件。

**对于成员变量来说，头文件的class是一个声明，所以它里面的变量也是一种声明，并不是一种定义，只有在下面这张图里红圈圈的地方，变量i才真正的定义了，因为a是A的实例，a具有A里所声明的东西**

==成员变量不在类里，在类的每一个对象里==（A a,A b 现在是两个对象）

**介绍一下语法：即使a具有了A的一切，但也不能这样调取i，*a.i*,因为i是私有变量，不能在A以外的地方调用它，但f()是公有的，所以可以用（如果i是公有的，那么也可以写成a.i）**

<img src="https://s1.imagehub.cc/images/2024/11/24/e5b79d0d6bd971da124411a6bd0e22c0.png" alt="image 20220125104429856" style="zoom:50%;" />

对于一个本地变量我们曾经说过，如果你像下面第1行这么写，那么是一个声明，这个g并不真的存在，只是告诉编译器会有这么一个g存在，只有当第2行才算真正的定义了g

但是对于成员变量来说，尽管我们说class仅仅是一个声明，但是我们也很少像第三行这样真正去定义它的存在。

<img src="https://s1.imagehub.cc/images/2024/11/24/9943c3d95974b66e576ba14acdbae3b5.png" alt="image 20220125104257933" style="zoom:50%;" />

## 6.成员变量的秘密

本地变量和参数实际上是一样的东西，他们的存储属性都是本地存储（进入这个函数之前，这些东西都不存在；进入函数之后，这些东西存在了；出函数之后这些东西又不存在了）

规则：==类的函数可以使用类的变量。==（尽管变量在class里面仅仅是声明，但是成员函数用的时候只需要知道有就行，不需要知道它在哪里）

==成员函数是属于类的，而不属于类的实例（对象）==（尽管对象可以调用A a; a.f(); ）

==成员变量是属于对象的==



**这里之所以可以写成a.i，是因为我们把i放到 Public里面去了**

<img src="https://s1.imagehub.cc/images/2024/11/24/b3f747d0307400fb5443dcf8276a64ef.png" alt="image 20220125121957043" style="zoom:50%;" />

在我们这个图里面，f()会对i进行操作，尽管f()是属于类的，i是属于对象的，**但f()仍旧知道，是对哪个i进行操作，**如果f()不知道的话，他就不会在本图第3行里输出10。

佐证：



<img src="https://s1.imagehub.cc/images/2024/11/24/4e8f937aa31921042e18d443dd2508cb.png" alt="image 20220125122454600" style="zoom:67%;" />

在这里面，A又有了对象aa，但是当aa调用f()时，f()在它的函数体里（看上张图）去把aa的i和a的i搞混。

这就是我们所说的，尽管f()属于类，但是他仍旧能分清每个对象的i是多少

<img src="https://s1.imagehub.cc/images/2024/11/24/1d9edd7ac196bd9430abd4c059839a40.png" alt="image 20220126110334917" style="zoom:50%;" />

image-20220126110251188.png"  style="zoom: 67%;"

第1行和第2行地址一样是因为，对象里面就只有这一个成员变量，所以地址一样。

第3行更佐证了我们之前的说法，f()里面得到的i就是我们之前 a的i

:fish:函数之所以知道自己对哪个变量作用，

这是因为所有的**成员函数都有**一个隐藏的变量，我们看不见也不需要去定义它（但你可以拿来用哦）

叫做**this**

 this是个指针，指向类的对象。它的类型是函数所属的类的对象的类型。

它的地址是成员变量的地址（和i一样）

因此，在成员函数内部，它可以用来指向调用对象。

由于this是个指针，所以你在写i = 20的时候，可以写成this->i = 20;  (this是指针，指针所指变量的成员用->表示)

<img src="https://s1.imagehub.cc/images/2024/11/24/0e4198e3aed50fe904c85a30f2b4fb39.png" alt="image 20220126112124316" style="zoom:50%;" />



这也是为什么成员函数知道他用的是哪个对象的成员变量

是因为如果你要在函数体里面用到i，成员函数会默认的给i前面加上this->



## 7.构造与析构

<img src="https://s1.imagehub.cc/images/2024/11/24/7c248abd0234b0715461194018ebadb6.png" alt="image 20220128164425602" style="zoom:33%;" />

你可以看到标题，它其实是程序中的其中一句话，在程序中的第3行。

同时呢，在程序的倒数第3行，我们也用了init来传入一些值。

那么init()是干什么的呢？

在C++里，如果我们声明了一个变量，那么编译器并不会去给它赋值，这也就是脏数据的可能性。

所以init()相当于一个初始化函数，给他初始化赋一些值



但同时也意味着这依赖于程序员的个人修养，如果他忘了写init()呢

所以我们需要有种机制需要保证无论什么程序员来写都是对的

<img src="https://s1.imagehub.cc/images/2024/11/28/9db9269b1f6196390bbc5e0ec0b25581.png" alt="Snipaste 2024 11 28 16 14 03"  />

我们利用constructor来保证变量，对象只要被创建出来就能够被正确的初始化。

constructor是一种特殊的函数，因此中文会写成构造函数。

**其实构造函数的全称是constructor function。简称constructor。**

**而constructor其实严格翻译叫做构造器。**

:flags:构造函数的名字和类的名字相同

```C++
class X{	//X是一个类
    int i;	//如果不加private还有public，成员函数和成员变量默认是private
public:
    X();	//“X”指的是X这一类的一个构造函数
};
```

构造函数没有任何返回类型。

构造函数会在对象被创建的时候自动被**调用**。

**构造函数的声明要在类里，但是定义可以在类外哦（是不是和成员函数很像）**



:flags:解释说明：

针对这句话：

==构造函数会在对象被创建的时候自动被**调用**==

```C++
class A{
public:
    int i;
 	f();
}
void A::f(){
    i = 20;
}
A::A(){	//这个是构造函数的详细定义喔 首先它的名字必须与类一样 其次它并不像别的函数会写void一样的返回类型
    i=0;
    printf("A::A--this=%p\n",this);//由于this是绑定在成员函数上的，而构造函数也可以看作是一种成员函数，所以当下面的A a，创建对象时，就会把a的地址给this，所以这里打印出来的就是对象的地址喔
}


int main(){
    A a;		//在对象被创建的同时，构造函数已经被调用了喔，也就是这时候console台上有构造函数的那句printf语句打印
    A aa;		
	a.f();
    aa.f();
}
```



:flags:回归正题，既然构造函数的创建是为了对象被自动的初始化，那么我们怎么进行初始化呢？如果我们希望初始化的时候，被赋予一些特定的值而不是一些默认的值呢？

那肯定需要传参了，那具体怎么传参呢？

A a(12);	//我们想给a初始化为12，这一个初始化的值一定要加入圆括号哦

具体解释：

当你创建A a；其实也发生了a.A()；指的是对象a去调用构造函数，

那么A a(12); 这个()圆括号可以看作是构造函数的那个()，我们都知道()在函数里相当于调用。12就相当于传值。

---

**析构函数(destructor)：**构造函数是当你的对象被创建的时候要调用的，析构函数是你当你的对象被消灭的时候要调用的。

下面说一下析构函数怎么声明

```C++
class X{	
    int i;	
public:
    X();	//构造函数
    ~X(); 	//析构函数
};
```

* 析构函数也没有返回类型

* 析构函数不能有参数
* **被析构之前，析构函数会被调用**（析构意味着对象的空间要被收回）

:flags:举一个析构函数的例子：

<img src="https://s1.imagehub.cc/images/2024/11/24/a44e6d5cc3bb490233dd476bea53be30.png" alt="image 20220128173648338" style="zoom:50%;" />

在倒数第3行也就是鼠标光标所在的位置，这是一个大括号的后半部分它对应了上面的一个大括号。

在这对大括号之中定义了对象小t，出了这对大括号的时候，t将不复存在（为什么不复存在呢？联想一下之前学到的，函数里面也有局部变量，这个局部变量只在函数内部存在，所以我们这里的对象也只在这一对大括号内存在）

析构函数先简单的讲一下，它的作用，有时候在对象的生命周期内，我们用对象做一些事情，那么出了这个生命周期，**我们希望对象的全部资源都被释放掉，就可以用到析构函数。**



## 8.对象初始化

**编译器会在作用域的大括号开始就给变量a,aa分配空间。但是构造函数的调用会在变量定义的地方才发生**

<img src="https://s1.imagehub.cc/images/2024/11/24/4bfefda447f749e7475edc87719710b4.png" alt="image 20220130184335787" style="zoom:50%;" />

但是构造函数是运行到那一行才会被调用。



下面这组图呢是说， X1身为一个对象，他会在void f(int i){的这个左大括号一开始就会被分配空间，但是到了X x1那一句才会调用构造函数，如果那句go to jump one没有注释掉的话，那么执行完那一句会直接跳到jump one而不会出现X x1，所以x1的构造函数不会被调用，所以当f()的｝右边画括号快要截止的时候，要调用析构函数的时候，由于根本没有初始化，所以析构函数也不能正常调用

<img src="https://s1.imagehub.cc/images/2024/11/24/51d0c5835d4858c88162be6d2418d7ff.png" alt="image 20220130184802210" style="zoom:50%;" />



<img src="https://s1.imagehub.cc/images/2024/11/28/c99918e48d8ac74b86671c4409df3ae1.png" alt="Snipaste 2024 11 28 16 16 37" style="zoom: 80%;" />

嗯，首先大标题第1个单词应该是总的 的意思，意思就是说很多初始化方式的一个汇总，这些初始化方式基本上都是C语言，可以用C++也可以用，只不过对于最后两行来说，C语言可能不太可以用。

蓝点点是每一种初始化方式，黑点点相当于蓝点点的一个附属点点。它是在蓝点点的基础上进行的一些

对于倒数第2行来说，我们首先声明了一个结构体，在C++里，struct和class是没有区别的。

倒数第2行里面它有三个成员，最后一个让人感觉很奇怪，首先它是一个函数，其次这一个函数和结构体的名字一样，所以它是一个构造函数，而括号里面就是它的参数。（看看下面第3行，i=a，是一样的道理，）

<img src="https://s1.imagehub.cc/images/2024/11/24/4f2b56bb1c9a68b338b20a969f4d3727.png" alt="image 20220214234242092" style="zoom:50%;" />

最后一行里面，我们相当于用这个结构体定义了一个实例，这个实例是一个数组数组里面是三个成员，相当于给每个成员一个初始化，相当于X x1 ={1,2.2,'c'}

最后一行里面三个成员的括号里面，就是初始化的值，你可能会说初始化为什么要在函数里面？老师说是因为，Y有构造函数，所以就只能用这种方式初始化（我也不懂，他说X没有构造函数，可是我觉得有实例有对象出来不就是有构造函数吗？）

:fishing_pole_and_fish::我后来结合了一下下面的知识，我大概推测是这样，就是一般来说你不在类里面写构造函数编译器会给你一个auto default constructor，也就是说也会进行初始化，但是这里面既然你自己在class里面写了构造函数，而且你还在class的声明里面用了构造函数，那么你在初始化的时候，当然要把自己的锅给接住了，自己挖的坑自己填，用这种方式来初始化



<img src="https://s1.imagehub.cc/images/2024/11/28/be7da99330545c78ebbede28f5e2a269.png" alt="Snipaste 2024 11 28 16 17 14" style="zoom:50%;" />

只要没有参数的构造函数就叫default constructor.      

default：默认

编译器默认给的是**auto default constructor**

![image 20220214233938840](https://s1.imagehub.cc/images/2024/11/24/4bda6679516d8df45e249839b3b0703c.png)

这个蓝色的是我们之前写的，这里面Y是有参数的，所以他不是default Constructor.

黄色的也是我们之前写的，

这个粉色的，我们要求他要有两个元素，但是现在只给一个元素，初始化了是错误的，并且如果你犯了这样的错误，编译器给你的东西，你大概率看不懂

![image 20220214234430423](https://s1.imagehub.cc/images/2024/11/24/957572fce7c943353a9ba1950c868b27.png)



## 9.new&delete

动态内存分配

<img src="https://s1.imagehub.cc/images/2024/11/24/6cd42af329d1fde1e1729fe8dce7849d.png" alt="image 20220215082655349" style="zoom: 67%;" />

new后跟着数据类型或类

new要做三件事情：分配空间，（对于类来说调用它的构造函数），作为一个运算符它要返回结果（返回地址）

delete有两种，如果new的时候带着方括号new的，那么delete的时候要用方括号delete，往后解释。



*当要new的时候先分配空间，分配完了再初始化。delete的时候先析构解决掉变量，再收回空间*

<img src="https://s1.imagehub.cc/images/2024/11/28/892e80344ba117c9a7c43fd7a015a7fe.png" alt="Snipaste 2024 11 28 16 18 02" style="zoom: 80%;" />

new是在程序运行过程中会申请空间，你可以通过指针访问它

delete能够让你不需要用这块内存的时候把内存还给系统

![Snipaste 2024 11 28 16 18 43](https://s1.imagehub.cc/images/2024/11/28/acc385874e7266089fca08da51dd9124.png)

operator:操作符

brackets:指的是[ ]

**new一次申请了10个int的空间，之后你需要用带方括号的delete去释放它。方括号是告诉程序，psome所指的地方不是只有一个东西，而是很多个东西，方括号能够保证psome所指的那么多个内存位都能调用析构函数，而不是仅仅只调用第一个位置的析构函数。如果你没有带方括号，空间还是被回收，但是析构函数只会调用一个。不带方括号的delete是告诉编译器psome所指的位置只有一个对象，所以只需要调用所指位置的那个析构函数就可以了**

---

在程序运行前，操作系统会提前给你程序一些内存，所以当你使用new的时候，并不是跟操作系统要内存，而是跟操作系统提前给你的那块内存里申请内存

---

![image 20220215084826566](https://s1.imagehub.cc/images/2024/11/24/45b9d978691bd406c843097e6b846989.png)

如图是指针指向内存，第1块内存是4个字节，第2块内存是40个字节

每当你像这样有一个指针指向内存的时候，系统都会有一张表记录下来，记录的内容是：所占内存的大小和地址

![image 20220215085056705](https://s1.imagehub.cc/images/2024/11/24/888c65433508e85252992e3cefd7495a.png)

<img src="https://s1.imagehub.cc/images/2024/11/24/14c32a45a4f97ee3ecd92424d88a9b74.png" alt="image 20220215085639195" style="zoom:50%;" />

当你去delete的时候，比如你说delete p，而p是一个指针，本质是一块地址。系统会查找那个表上有没有记录这个地址，有的话可以查到需要删除多少内存。（==会先根据p的类型调用析构函数，然后查表看是否存在，存在的话再回收空间==）**析构是先清空内存上的数据，下下一步回收空间是说这块内存收回去了**



image-20220215085811097.png"   style="zoom: 67%;"

但如果你这么写，a是一个指针存储地址，对a++，a的地址会变成下一个数据单元的地址。比如a指向数组第一个格子，当你加加，a会指向第二个格子的地址，同理，P+2表示p在内存中前移两个int的距离。

所以当a存储的地址变动后，再去delete，系统的表上没有记录这个地址，就会出一个运行错误。



<img src="https://s1.imagehub.cc/images/2024/11/24/ae5c6d76d3b907f6d50c7bb56d8db028.png" alt="image 20220215090525759" style="zoom: 50%;" />

假如说这个指针叫做r，当你只写delete r而不加方括号的时候，系统会认为你只删除那个地址上的内存，

如下

<img src="https://s1.imagehub.cc/images/2024/11/24/b4162e67b2fc592e3797adfb609bf34c.png" alt="image 20220215090830354" style="zoom:50%;" />

析构后，

image-20220215090913774.png"  style="zoom:50%;" 

回收空间后，下面就什么也无了

image-20220215090930860.png"  style="zoom:50%;" 

image-20220215090936954.png

看另一个例子，系统先根据r的类型去调用r的析构函数，<img src="https://s1.imagehub.cc/images/2024/11/24/a079319762be38393b291859cca357e7.png" alt="image 20220215090725414" style="zoom:50%;" />

但是在回收空间的时候，整块内存都会被回收掉，也就是160个字节都会被回收掉，毕竟表上可是写着160呢，当然会回收160了。

只不过析构的时候只会析构一块



如果你在delete的时候加上方括号，那么系统会知道你这里是有多个对象需要被析构的，首先调用析构函数，然后他会计算你有多少个对象，用160除以第一块内存块（r所指的地址的内存大小）就知道一共有几个内存块，也就是有几个对象需要析构。

然后会调用10次析构函数，依次把所有的内存一个一个析构掉。

----

<img src="https://s1.imagehub.cc/images/2024/11/24/cd6be13d52b1f741bc1b8aa507759ed5.png" alt="image 20220215103254375" style="zoom:50%;" />

对于上面这个图，你可能对于set函数很懵逼，这两个i难道不是一个i吗。

我也只能浅浅的解释一下，不知道对不对。<img src="https://s1.imagehub.cc/images/2024/11/24/6740b0abc3c3be297bbc2b516f4ae429.png" alt="image 20220215104309976" style="zoom:50%;" />

我把里面的i都改成了c,这样看着就顺眼很多，但是我还是会想，这两个i的作用域是否有冲突？应该不会.在for循环里，出现的a的意思始终就是这个C的意思，并没有出现类的成员变量，也就是真正的i。

所以下面是控制台的结果，应该就看得很清楚了，

这十行重复的都是构造函数调用的，毕竟我们可是创建了10个对象，

但是由于我们delete并没有加方括号，所以析构的话，只会析构一个对象，也就是最后一行，

我们也可以看到i=0，这意味着只有第1个对象被析构



<img src="https://s1.imagehub.cc/images/2024/11/24/67598d457528332afdcc69d1275aee73.png" alt="image 20220215103350871" style="zoom:67%;" />

<img src="https://s1.imagehub.cc/images/2024/11/24/61519038b550b8b39faade8a589fb9b7.png" alt="image 20220215103412351" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/24/03a5ea3a722712e656537b530f942e93.png" alt="image 20220215103433318" style="zoom:50%;" />

上面的结果应该可以看得很清楚，但唯一不清楚的是delete，为什么要从最后一个对象开始析构

这个就得问编译器啦 这里不说了

---

:fish:：

* 不要用delete释放不是new分配出来的空间
* 不要用delete两次释放同一块空间
* 用了带[]的new也要用带[]的delete
* 如果new的时候不带[]则delete的时候也不要带[]
* delete一个null pointer是很安全的事情

<img src="https://s1.imagehub.cc/images/2024/11/24/286da7344e0e6843b9738319fc84e46c.png" alt="image 20220215105611722" style="zoom:50%;" />

最后一个tip可以看看下面这张图，我觉得null pointer指的就是不指向任何地方的指针，如果你是有一个这样的指针，你去释放它的时候，尽管没有用new，但是也可以成功释放

==***\*C++在new时的初始化的规律可能为：对于有构造函数的类，不论有没有括号，都用构造函数进行初始化；如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，而加了括号的new会在分配内存的同时初始化为0。\****==



## 10.访问限制

一些限制规则：

* 使用你类的程序员不能随心所欲访问类里的一些东西
* 同时可以让写这个类的人可以去修改内部的东西而不至于去影响到别人



C++所有成员可以是这三种访问属性之一：

* public（任何人可以访问）
* private（只有类的成员函数可以访问）
* protected（只有这个类自己以及类的后代可以访问）



<img src="https://s1.imagehub.cc/images/2024/11/24/4a5932dc3dbcb38eadf656c442b5125e.png" alt="image 20220215111229080" style="zoom:50%;" />

先看class里，我们在public的最后一行写了个g()

看看console出一些什么吧

编译报错

所以我们要**在构造函数里加上P=0**（这个我真的看了很久很久，最后发现是类A里面， Private里面有一个指针P

此时console一下

<img src="https://s1.imagehub.cc/images/2024/11/24/d5d813e538dbc72cc9887a3e83995cfc.png" alt="image 20220215130318105" style="zoom:50%;" />

![Snipaste 2024 11 28 16 19 52](https://s1.imagehub.cc/images/2024/11/28/9043c678d4cab2f6e886bab5b100ca53.png)





**同一个类的对象之间是可以访问私有成员变量的**

就像p访问了b的i

**所以private是对类来说的， 你们是同一个类就行**

---

 Private权限的限制仅仅在编译时刻，只要编译器没发现你作为一个对象把手伸到另一个对象的私有成员变量就行，编译器没发现就行，到了运行时刻没有人管

C++的OOP特性只在源代码级别存在，编译完之后就不是OOP的东西了

C++编译完之后生成的.o和C语言编译出来的.o和汇编语言的.o是一模一样的

所以编译成可执行代码后，（成为了二进制代码）已经丧失了C++语言的所有特性，（这里的编译是泛指，在目录上也有具体讲解，）

<img src="https://s1.imagehub.cc/images/2024/11/24/e48b06ed4d44cdf2e499362b0ce45c79.png" alt="image 20220215132556351" style="zoom:50%;" />

---

C++还有一个破坏OOP原则的东西叫做

![Snipaste 2024 11 28 16 20 24](https://s1.imagehub.cc/images/2024/11/28/157f51afec3d789111adef4de7c65d8a.png)

* 一旦声明别人是你的朋友，他就可以访问你的private的东西了。这个别人可以是别的类，别的函数，别的成员函数（这里面的关系是你说别人是你的朋友，你让朋友来访问你的。而不是你说你是别人的朋友，你去访问别人的）
* 第2句英文我看的也不是很懂，但我猜测是说friends是要在类里面声明的，你可以看看下面举的例子

---

<img src="https://s1.imagehub.cc/images/2024/11/24/da28d751244f70007f0475df1a2b6c93.png" alt="image 20220215133557671" style="zoom: 50%;" />

在第1行里面，按理说我们声明一个结构体都要写个大括号来说，里面的具体的内容，但这里什么都没有写，它的目的就是告诉编译器说我有这么一个东西，有个X，具体是什么不用管，当然我们也看到后面也写了具体是什么。

提前告诉编译器有一个X是因为我们下面的Y就要用到X，如果你不提前告诉编译器有一个X，那么到了Y里面，他发现X没有声明过，他就会报错，而你提前告诉了编译器，所以这里也不会报错，更何况我们也没有对X进行任何的操作，只是说了有这么一个函数。

*关于为什么这里面相当于对X没有做任何的操作，是因为联想一下我们的指针*int* p*这里的int指的是变量p的类型，我们这里只写了X星，也就是只说明了指针的数据类型，那你会说数据类型有好几种，所占的内存大小也不同，==这是因为对于结构体而言，指向结构体的指针大小都是一样的==*

但是如果你像下面这么写，他也会报错，我个人是觉得，因为我们还没有具体的声明X，你就创建了他的对象编译器，不知道这个对象是什么

<img src="https://s1.imagehub.cc/images/2024/11/24/60417b0ea236976124608adc2a112115.png" alt="image 20220215134006799" style="zoom:50%;" />

X展开是下面这样的

<img src="https://s1.imagehub.cc/images/2024/11/24/7618b930bd89a25da80ab6bb9f200411.png" alt="image 20220215133820055" style="zoom:50%;" />

可以看到倒数第4行里面我们提到了friend，这句话的意思是我们授权Y的f()可以使用X，

---

==class vs struct==

对于class来说，如果你不标明成员的属性，比如说清楚他是private还是public,那么class会默认为private

但如果对于struct来说，如果你不标明成员的属性，他会默认是public



## 11.初始化列表（list initialization）

这是之前我们的代码，注意有灰色光标的那一行就行，也就是构造函数那一行

<img src="https://s1.imagehub.cc/images/2024/11/24/0688f2f73d04f88a7e96c2725affd85d.png" alt="image 20220217110712828" style="zoom:50%;" />

​	下面是另一种写法

<img src="https://s1.imagehub.cc/images/2024/11/24/a37d07973ee0c0f8df052cf094930271.png" alt="image 20220217110611428" style="zoom: 33%;" />

这种写法叫做初始化列表，它是在构造函数后面加上一个冒号，然后写上成员变量的名字，然后再在后面的括号里面写上要初始化的值

:fish:：你可以看到在下面的构造函数里，我们既给构造函数进行了一个初始化，给后面还加了一个列表，初始化说明两者并不冲突，**其实他们的区别是列表初始化是早于构造函数里面的内容被执行的**



<img src="https://s1.imagehub.cc/images/2024/11/27/6ce46cb88f58becb6e69b48e94d0b377.png" alt="image 20220217110915635" style="zoom:67%;" />

---

我们把在构造函数画括号里面写的看似很像初始化的东西叫做==赋值==，列表初始化的方法，初始化的才叫做==初始化==，注意要区分哦

![image 20220217111632769](https://s1.imagehub.cc/images/2024/11/27/5b602a4b3576250fa619287d66f6279b.png)

像上面那句话前面的student是说这个类，然后两个冒号是说这个类的构造函数，（string s）是构造函数的参数，后面的是给他列表初始化的东西，而构造函数里真正的内容花括号里面还什么都没写，这里面我们就是先进行了一个初始化

![image 20220217111747627](https://s1.imagehub.cc/images/2024/11/27/b1600f3bc967cee4c06023640f73001b.png)

上面这一句我们就是没有进行初始化，而只进行了赋值

==初始化是早于赋值被执行的==

![Snipaste 2024 11 28 16 21 01](https://s1.imagehub.cc/images/2024/11/28/2ef5091150fd7a01760c7e2f0442cd4e.png)

<img src="https://s1.imagehub.cc/images/2024/11/27/dc17cf16bc73a59621c9765b1647d90f.png" alt="image 20220217111942070" style="zoom:50%;" />

正会报错，但是像下面这样写的话就不会报错，

image-20220217112417822.png   style="zoom:50%;"

这两行B，我觉得都是构造函数，老师说有两个构造函数并不是错误的，但是具体为什么他说以后会讲，这里面具体原因他也没有说，但我推测下面的构造函数是一个 Default constructor. Default constructor并不是系统默认给的，他只是没有参数的构造函数罢了，系统默认给的是auto default constructor

:fish::反正老师给的建议是以后写类最好都用列表初始化，而不是要在构造函数里进行赋值

## 12.对象组合

image-20220216230739293.png

重用的实现需要学会**组合**（Composition）：用已有的对象构造出新的对象

就像汽车是用引擎和轮胎组合成的

<img src="https://s1.imagehub.cc/images/2024/11/27/7a33bae1b44d848828ae1914aee62df7.png" alt="image 20220216231042585" style="zoom:33%;" />

**组合：**

* 对象可以由对象构成

* 组合的方式

  * Fully (对象2是对象1的一部分) 比如类的成员变量1又是由对象2构成的
  * By reference（对象1知道对象2在哪里，也可以访问对象2，但对象2不是对象1的一部分）比如类的成员变量1是个指针，指向对象2

  * 至于什么时候用fully，什么时候用reference，取决于语义本身，比如心脏就适合放在，对象里面，而书包适合放在对象外面。

这就好比现在有一个类，这个类的数据有名字，家庭地址，职位，上司是谁。

很明显这个类是一个人，你创建不同的对象就可以表示出不同的人

那么名字地址职位，每个人都不一样，那么上司呢，很多人的上司可能是同一个人，所以你可以让这个上司，作为成员变量指向另一个对象。

<img src="https://s1.imagehub.cc/images/2024/11/27/3fed462a9ef411e488f4b49852f561e1.png" alt="image 20220216234537760" style="zoom:50%;" />

supervisor:主管

![Snipaste 2024 11 28 16 21 26](https://s1.imagehub.cc/images/2024/11/28/22d534257d5df99f81a7f703073b3f99.png)

currency：货币

savingaccount：储蓄账户

SavingAccout里的public分别是构造函数和析构函数，还有打印函数

private里是两个别的类的对象

<img src="https://s1.imagehub.cc/images/2024/11/27/709e30059d667fdb4b6567918fd8102a.png" alt="image 20220216235534828" style="zoom:50%;" />

外面的大方框是SavingAccount，里面的P和C就是Person类的对象和Currency的对象

但尽管这两个对象在SavingAccount里，但这两个对象仍旧具有独立的人格，你只能用它们给外界提供的方法，不能随意调用私有成员变量

:fish::下面有一个，我觉得老师不是讲得很清楚，我自己就这么想的啊，就是这两个对象，他不是有自己独立的人格吗？所以你给他们初始化的时候，你还要用到这两个对象各自的构造函数，还得让他们自己调自己的构造函数，先不说他们的构造函数会不会突然设立成私有的，就说你是不是得等这两个对象创建之后，他们调自己的构造函数之后，你才能使用这两个对象，那万一你想在他们，要用构造函数之前，你就想用这两个对象的初始值来做一些事情呢

**所以这个时候就要用到列表初始化了**，因为列表初始化这个动作会在构造函数之前就执行

---

<img src="https://s1.imagehub.cc/images/2024/11/27/c1778f84100b28aa319f34a5efdd52cf.png" alt="image 20220217115635137" style="zoom:50%;" />

这个例子有很多可讲的东西，首先上面是一个构造函数的列表初始化，比较长，不过你可以看到花括号里面是空的，在这里的列表初始化，我们初始化的是两个别人的对象的，这里面你可能会说，既然都列表初始化了，为什么不直接传值呀？还要写这些像参数原型一样的东西。

我们在这里面确实没有传入具体的值，这里面其实列表初始化也就是冒号后的内容，是这两个对象各自的构造函数，我再强调一遍，我们确实没有传入具体的值，我们在冒号后面调用的是他们各自的构造函数，**但是想要让这种写法编译的时候不报错，你也需要在这两个对象的类里面的构造函数再写一个default constructor，因为我们在调用它们构造函数的时候确实没有传值，所以你一定要在这两个对象的类里面写一个default construct**

---

这里面我们要再说一下边界感，尽管这两个对象的确是在saving accounts里面创建的，但是对象里面私有的东西还是不可以随便的拿来用，

**如果你的类里面有成员是对象，那么你就应该用列表初始化**

**如果你的成员不是别人类的对象，那你也应该使用列表初始化**

-----

:tropical_fish::但是现在我们要来说另一种情况，刚才我们那两个对象都是类的private里面的，那如果你把这两个对象放在public里面呢，其实你是可以随意访问对象里面的东西的，即使访问他私有的东西也是可以的

<img src="https://s1.imagehub.cc/images/2024/11/27/681dd875e4538f7b7e06b00ade023e07.png" alt="image 20220217124433719" style="zoom:50%;" />

## 13.继承（inheritance）

继承和组合一样，都是在面向对象中重要的组件。

组合：用已有的对象拼装出新的对象	（对象拼出对象）

继承：拿已有的类，在类的基础上进行改造得到一个新的类（类改造成另一个类）



允许共享的设计有：（如果你从一个类里面继承，那么你就可以继承到以下这些他原先设计好的东西）

* member data
* member functions 
* interfaces

分别指的是成员数据，成员函数，接口

那么接口与成员函数的区别是什么呢？在类里面成员函数也可以是private的，所以只有放在public里面的成员函数才是接口

同样的在public里面的成员数据也可以是接口

---

<img src="https://s1.imagehub.cc/images/2024/11/27/411c4f5ba5df309d5ecdada2cd66ed22.png" alt="image 20220220194848873" style="zoom:50%;" />

在这里面是有两个类，一个是person，一个是student，从字义来看， Student属于person，那么student一定继承自person，那为什么student会比person还大呢？（student是person的超集）

**继承具有这样一个能力：将一个类的behavior或者implementation(实现)定义为另一个类的超集**

放到这里面来看，就是作为一个人，他的属性可能是国家身高体重，但是作为一个学生，他拥有的属性一定更多，不仅具有人的一切属性，还会有他的学校在学的专业老师班级等等

作为人的一些属性和行为学生一定有，但是作为学生所具有的一部分属性和行为，不一定其他人也会有

---

![image 20220220195844716](https://s1.imagehub.cc/images/2024/11/27/4f28186c7479838daf265b181d80fd86.png)

我们有时候也会用一些图来表示关系，上面的是父类，下面的是子类

英文从上到下翻译分别是（不包含职员和经理）基类，超类，父类	。	派生类，子类，子类

---

<img src="https://s1.imagehub.cc/images/2024/11/27/e3216349ec7a8f71acf6f1ecb0bfc2f5.png" alt="image 20220220200611044" style="zoom:50%;" />

console：

<img src="https://s1.imagehub.cc/images/2024/11/27/8064d0534a540c2ba34dd1607a06001d.png" alt="image 20220220200643447" style="zoom:50%;" />

首先这里面要注意的是，继承的那个类的写法，==class B : public A{ }==这个public是一定要加的，不加就会是别的含义，虽然说这个B不仅继承了public，也继承了private。

在main()里面创建了B的对象b,要注意的是，**是classB继承了a全部的东西，而不是小b，b只可以调用class A里面public的东西**

---

<img src="https://s1.imagehub.cc/images/2024/11/27/bf102d23824c561ba9c0222b4d2912b2.png" alt="image 20220220201317876" style="zoom:50%;" />

现在我们又往这个程序里面加了一些东西，是蓝色笔画的，这可是为了验证：给子类加上一个函数，让这个函数去掉父类的函数，能否成功？

<img src="https://s1.imagehub.cc/images/2024/11/27/662a9914bc6a603054019afc3f6c3791.png" alt="image 20220220201418638" style="zoom:50%;" />

成功了



---



现在验证一下能不能去调取父类private的东西（如下 我们修改了i）

<img src="https://s1.imagehub.cc/images/2024/11/27/68987e102e618366fa598a558820b7f7.png" alt="image 20220220201518688" style="zoom:50%;" />

编译失败

==父类私有的东西在子类是存在的，但是你不能碰==

父亲留给你一笔钱这个钱是你的，但是他是给了基金会，所以你不能直接的去花，你要通过一些规则（父类的public成员函数）才能去花

---

<img src="https://s1.imagehub.cc/images/2024/11/27/86c6bb0898049eb739296ad23c2699b7.png" alt="image 20220220201811959" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/27/61091daf7d7e1a3c3052cbdf3f0c3940.png" alt="image 20220220201918535" style="zoom:50%;" />

现在我们又进行了一些修改，在class A里面，把set()前面加上了protected。这个属性的意思是说只有他自己以及他的子类可以访问。



会显示编译失败，因为protected只允许自己和子类用这些可以用的，指的都是类，只有类里面能用，

哪怕是类的对象都不可以用，（见链接里贴的程序）

哪怕是在**main**函数中都不可以	(在类的成员函数外部，不能访问对象的私有成员和保护成员。)

:fishing_pole_and_fish::

**保护成员的可访问范围比私有成员大，比公有成员小。能访问私有成员的地方都能访问保护成员。**

**保护成员扩大的访问范围表现在：基类的保护成员可以在派生类的成员函数中被(直接)访问。**

http://c.biancheng.net/view/252.html





---

继承是子类继承父类，可以继承父类的成员函数，成员数据，接口。

但这不意味着子类的对象也可以随意访问private里面的东西，当然了，public里面的东西还是可以直接访问的。

子类虽然继承到父类的private部分，但是不能直接访问，还是要通过父类的成员函数才能访问。

==套娃：子类的对象想访问子类private的东西通过**子类的成员函数**；子类想访问父类private的东西要通过**父类的成员函数**==

**protected:**如果你在父类里面把一个东西的属性定义为 protected，那么这个东西只有自己这个类和子类能用。但是这个东西只有在子类的成员函数中才可以用，连在main函数中都不可以。（哪怕你在main函数中通过子类的对象调用子类的成员函数都不可以）



---

<img src="https://s1.imagehub.cc/images/2024/11/27/ab902d869f628e67bf8f63823fb9fcc6.png" alt="image 20220220204523602" style="zoom:50%;" />

下面是说我们自己在写累的时候怎么去规划哪些东西放在public里面，哪些东西放在private里面，哪些东西放在produced里面。

sees代表能看见的东西（虽然大家看不见private但不代表不能用，还是可以通过成员函数来用的）

Derived class:子类/派生类

Client Class：客户类（使用你这个类的类，它是base class的客户，但没有血缘关系，不是儿子孙子什么的）

注意左下角是pub2不是prot2

### private权限总结

使用方式：

* 同一个类的成员函数可以使用
* 同一个类的对象通过成员函数可以使用
* 在类里声明friend，别人就可以通过你的成员函数调取你了

**protected权限总结**

使用方式：

直属类（父子关系）的成员函数可以使用，在这些直属类里，protected等同于public

**public权限总结**

使用方式：

* 同一个类的对象尽管直接调用
* 别的类应该也可以调用，只要通过这个**::**符号说明是属于哪个类就行



## 14.子类父类关系

<img src="https://s1.imagehub.cc/images/2024/11/27/0692683048a7568274045aa8dbd21aa4.png" alt="image 20220222112513037" style="zoom:50%;" />

在上面这个图里面，我们出现了很多陌生名词，比如说括号里面的ostream，以及const，这些现在都不用去管它，假装没有看到，至于括号里面只当需要传入某种类型的参数就行，

这里面值得关注的是我们使用了protected，虽然我们在之前的确提到你可以使用这种属性，但其实他并没有private安全， protected的子类的成员函数可以修改父类protected里的东西，你怎么知道有没有不孝子孙给你把这个数据改乱了呢？但如果是private，无论是谁都没有办法修改你这里面的定义

第2个值得关注的是在employee The public里面我们声明了两个都叫print的函数，但是可以看到他们的参数是不一样的，如果两个函数名字相同，但参数不同，这个就叫**函数重载**，它们是两个函数。你在调用的时候你需要给出名字给出参数，所以编译器会根据你给的参数不同来区分，你要调用的是哪个函数

<img src="https://s1.imagehub.cc/images/2024/11/27/56bad1d1037d1e3339dcec852f8f6be2.png" alt="image 20220222112956128" style="zoom:50%;" />

上面是一个平平无奇的构造函数的定义，只不过用了一点列表初始化这里，只是放在这里，没有什么特殊目的

---

<img src="https://s1.imagehub.cc/images/2024/11/27/6c800966bd0ddb0b49bcdbea8d9b6631.png" alt="image 20220222114543203" style="zoom:50%;" />

上面的代码并不是新的代码上面的代码并不是新的代码，是我们把之前写的print函数搬下来，方便我们现在观看，可以看到在第2个print函数里面，它掉了第1个函数，因为它传入的参数只有一个out，这样调用是因为他并不想把第1个print函数里面out的两句语句再抄一遍，所以直接在第2个print函数里面采取了这样的方式

这里面蕴含了一个很关键的思想，**不想把之前写过的东西再抄一遍的话就要尽可能的利用它，比如我们这里的调用函数**



### 初始化列表第二种情况

<img src="https://s1.imagehub.cc/images/2024/11/27/467ee0a6a090476208dbe30e67334160.png" alt="image 20220222220449622" style="zoom:50%;" />

在最后一行里面，B有了对象b，当对象生成，会自动调用构造函数，而B没有，而B继承自A，所以自然调用A的构造函数。你可以选择B b的时候不传入任何值，这个时候就是一个default constructor，当然前提是你的A里得有一个A(){ }，此时我们没有，所以你必须传入一个值，那么怎么传呢？

B b(10)就可以了吗？实际上这样传值是传不到类A里的，

那怎么传？

在B类里写上，B( ) : A(15){ }

**父类的子类也要使用列表初始化**



其次呢，这里面涉及到了列表初始化的顺序

如果B里还有其他的成员变量，那么在B里的构造函数里，我们不仅需要给父类初始化，还要同时给B的成员变量初始化，这些初始化都是在一句完成的，也就是B的构造函数那一句，

那么顺序呢，我们是按照**声明**的顺序来初始化的，很显然父类最先声明，所以第1个初始化的一定是父类，其次呢，就是成员变量的声明顺序



**析构的顺序**：刚才说了，我们在初始化列表的时候，我们按照声明的顺序来初始化，实际上在调用构造函数的时候，也会先调用排在前面被初始化的构造函数，就比如A类是先被初始化的，所以先调用A类的构造函数，再调用B的。**这里面涉及到了一个知识点：**虽然a的初始化是在B的构造函数里面写的，但是实际上调用的也是A的构造函数，只不过我们是通过在B里面，来更好的传值从而传给A的构造函数

下面是析构的顺序，在构造函数调用的顺序是按照初始化列表的顺序，但是在析构函数调用的时候，会先调用B的B的结构函数再调用A的，这个可以理解成先把自己清理好，再去清理别人的

---

上面我们探究的问题是如果子类的函数和父类的一样，那么在main里面用子类的对象去调用这个函数的时候会发生什么？调用的是谁的？

<img src="https://s1.imagehub.cc/images/2024/11/27/c6b7396af6263f13eff488d6a460bc7d.png" alt="image 20220222222853480" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/27/eb3cde02e607d59881b67562bf5d9a7a.png" alt="image 20220222222954900" style="zoom:50%;" />

这样会报错，但是我们引用C++的知识是，

如果父类拥有几个重载的函数，也就是名字相同，参数不一样，而子类也正好有与父类同名参数一样的函数，那么父类的函数就会被隐藏掉（注意并不仅仅是父类和子类重名，重参数的父类的那个函数会被隐藏掉，而是父类，所有叫这个名字的都会被隐藏掉，、）也就是说父类的print函数都会被隐藏掉

这个是C++违反OOP原则的一个地方，C++认为如果出现了这样子类和父类的函数重名的情况，他会认为这两者之间没有关系，也就是父类的函数和子类的函数之间是没有关系的，然后为了避免错乱，他会把父类的所有的函数都隐藏掉

## 15.函数重载（overload）和默认函数

上一节貌似提到了函数重载指的是两个函数的名字相同，但是需要的参数不同，所以你调用函数的时候给出了名字后面的参数决定了你要调用的是哪个函数。



-那么现在我们可以抱有这样一个问题，如果两个函数名字相同参数所需的类型也相同，但是返回类型不同，这样是否构成函数重载？

-这样是不行的，因为你在调用的时候你肯定要给出名字和参数，那调用的时候编译器就不知道你要调用的是哪个函数了

![Snipaste 2024 11 28 16 22 51](https://s1.imagehub.cc/images/2024/11/28/adf0994a3a1e81e4e93c67bb7f691a5d.png)



### default arguments（默认参数）

Stash(int size, int init = 0)

这个类我们有两个参数，一个参数和以往的参数写法一样，另一个参数我们提前给了一个值

**Default arguments只能在.h文件写，也就是说只能在函数原型里面写（但还有一种写法，我会在下面写上）**

那么传值的时候 有两种写法

* Stash(2,5)
* Stash(2)

像第1种写法，你就是给两个分别一个初始值，第2种写法的话，即使没有给第2个参数初始值，它也有自己的初始值



<img src="https://s1.imagehub.cc/images/2024/11/27/cbaf2e5068610a7e35af4d2be159ad9f.png" alt="image 20220222230759362" style="zoom:50%;" />

像上面这种写法是错误的，因为你一旦给出使之你就要从右往左给。左边的有了右边的也一定有初始值。这里面m有了，j没有就是不正确的，

---

 Default arguments的第2种写法

<img src="https://s1.imagehub.cc/images/2024/11/27/6d2c9cdafa956fbffa24cfcf6c525ddb.png" alt="image 20220222232211874" style="zoom:50%;" />

这是因为我们编译器他，编译的时候不是会把头文件直接插到cpp文件嘛（通过include），所以总而言之，这两个文件也是要合在一起的，现在呢，你只不过就是把它写到了CPP文件里，也是没错的，而且你也是用声明的写法

---

老师建议不要用default arguments，因为在软件工程上一般让你省事的写法都会有安全隐患，

比如我们写Stash(1)阅读者会以为你只有一个参数，其实你可能初始化了别的参数而已



## 16.内联函数

当我们去调用一个函数的时候，有没有什么额外的开销，而没有方法去避免额外的开销

overhead for a function call

网易云那个视频分析了，我觉得很复杂，所以就不贴在这里了

下面我也写了一点

当你要去调一个函数的时候，

第一件这事情是它（编译器）要把参数送给那个函数的参数推到堆栈里面去。

第二件事情是函数要把返回地址推到堆栈里面去

然后在被调的那个函数里面呢，函数要准备那个返回的值，返回的值放在ax寄存器里面

然后要把所有push进去的东西都要pop出来

<img src="https://s1.imagehub.cc/images/2024/11/27/82b9b3c78cb64143b8539d20f9506feb.png" alt="image 20220223100440177" style="zoom:33%;" />

---

C++提供了一个手段，叫做inline内联函数，inline函数是说你可以给函数前面加一个关键字inline，加inline之后呢这个函数就成了inline函数。如果说这个函数是inline的，那么当我去调这个函数的时候，我不是真的去做我们刚才的那些动作去push call pop，而是把那个函数的代码嵌入到调用它的地方去，但是仍然保持函数的独立性（即函数有自己的空间）

即使成为inline函数，它还是会保留着以下操作：函数还是有自己的变量，有它的本地变量，那些本地变量进去的时候才有出来就没有了等等这一系列的。然后包括调函数的时候，你要对函数的参数进行检查。

但是呢并没有真的去调函数，而是把函数的代码放到调用它的地方去。

<img src="https://s1.imagehub.cc/images/2024/11/27/2084041eeae1ed04ef2104b7bb06a8b7.png" alt="image 20220223101221603" style="zoom:50%;" />

---

**inline写法**

inline必须在.h和.cpp文件都写上，.h是给调用函数的人看的，.cpp是用来产生函数的。（所以两个地方都要加）

但是要注意，有一个写法是不正确的（注意看整体，我没有说里面的任何一句话不正确，但是整体拼在一起就错了）

在.h里写

 inline void f(int i,int j);



在a.cpp里写

inline void f(int i,int j){

​	cout<<i<<" "<<j<<endl;

}



在main.cpp里写

int main( ){

​	f(10，10);

​	return 0;	

}

这种写法我们可以在目录的头文件源文件里面可以看到，他把CPP文件并没有放在一起写，而是分开写了，在本文中，我们在头文件和a.cpp里面加上了inline，编译器肯定首先在main函数里执行，当他执行到f(10,10)的时候，并没有看到inline的影子，所以他就把这个函数当作一个普通函数来处理，生成一些普通函数该生成的东西（如果是inline函数，是不用生成任何东西的，只需要把代码嵌入进去即可）

那么你会说，我在a.cpp里都声明过这个函数是inline，为什么编译器会不知道呢？我个人觉得是因为这两个CPP文件不在一个文件里面，所以知道他是内联也没有什么用，因为我们把inline这个标志应该加在调用他的地方，这样就可以在调用他的地方直接嵌入代码（对于源文件当他想用到头文件资料的时候直接使用include，但是他想要用另一个源文件的资料，只能通过调用）

现在继续说本文的这一串代码，在main.cpp里，由于并没有看到内联的影子，所以编译器把它当做普通函数处理，生成了一些东西，所以在编译阶段都是没有什么错的，真正的错误出现在最后要把他们连接起来的时候，main.cpp由于生成了一些东西，所以它需要在这时候调用F函数，但是在a.cpp里由于是内联的，所以并没有产生什么额外的东西给main里要用它的地方，所以会报错

改正方法：

在.h里写

inline void f(int i,int j){

​	cout<<i<<" "<<j<<endl;

}

在头文件里面把函数的body也加上，那么在main.cpp要用F函数的时候，正好通过include得知这是一个内联函数

不过这里面还有一个小问题，就是在头文件里面我们一般是不会对函数进行定义的，但是你定义里没有什么错，只不过我们在定义里面使用了cout语句，需要加上

```
# include< iostream >;using namespace std;
```

在头文件里面也是可以这样写的

不过对于我们这个代码来说我们这里面有两个源文件，所以a.cpp和a.h对F函数的重复内联声明肯定是重复了的，就不需要存在a.cpp即可

==在一个函数前面加上inline，这个函数其实相当于是一个声明，而不是定义==

==因此Inline不需要放在源文件里，只能放在头文件里==

---

内联函数由于会嵌入，所以它会增加程序额外的内存开销，但是它减少了很多overhead（额外的开销）（以空间换时间）

这个东西比C的宏要好，宏是不能做类型检查，而inline作为函数来说会做类型检查

---

如果你的这个内联函数非常大，要么就是内存增长迅速，要么就是有递归编译器都会==拒绝==帮你Inline

---

:family_man_woman_girl_boy:

如果你在class声明的时候就给出成员函数的 body(定义)，那么默认都是Inline

<img src="https://s1.imagehub.cc/images/2024/11/27/bfa3c763687834f73efed2ff7f198b38.png" alt="image 20220223104747356" style="zoom:50%;" />

这三个函数都是inline



:family_man_girl_boy::第二种写法

<img src="https://s1.imagehub.cc/images/2024/11/27/b8006759d509306ac369cad233e2341e.png" alt="image 20220223105019706" style="zoom:50%;" />

上面这些都全部是在头文件写的，因为我们说了给函数前面加上内联，它是一个声明，如果你觉得把函数的body放在class，说明里面显得非常的乱的话，那么你也可以像这样写在下面

---

什么情况下使用inline？

-如果你的函数很小，只有两三行,可以使用

-如果你的函数是需要反复被调用的，或者说在一个循环里面或者是很大就不要用了

## 17.const

<img src="https://s1.imagehub.cc/images/2024/11/27/a278811b144f2c9f39b50a88592722e8.png" alt="image 20220223160906802" style="zoom:50%;" />

const就是一旦定义下来，不能修改值。

但是要区分const与常数，const是一个变量，就是要被分配内存的。而常数不用被分配内存，只用在编译器的表中记下来即可

---

**编译时常量（Compile time constants）**

下面是编译时刻知道值的const，这个变量的值是必须在编译时刻被知道

```C++
const int buf = 1024;
```

可以看到extern并没有赋初值，extern是说buf是定义在某处的全局变量，这个全局变量的类型是const，buf可以用，某个地方有，但是在这里不准赋初值

```C++
extern const int buf;
```



extern就像一个老大哥一样，它告诉编译器说buf就是const，哪怕buf并不真的是const，编译器也会信（但其实对比上一个例子，你会发现编译器此刻并不知道值，我个人觉得const是一定要初始化的，但这时候由于有extern欺骗编译器，所以编译器就信了）



**运行时常量 (Run-time constants)**

```C++
const int class_size = 12;
int finalGrade[class_size];	//✔
```

在上面这段代码里，如果你定义了一个变量，并进行初始化，在后面及时使用这个变量是没有关系的，它已经等同于常量了

```C++
int x;
cin >> x;
const int size = x;
double classAverage[size];//✖
```

但是像下面这样，尽管你输入的x也是一个整形，但是在编译时刻编译器并不知道size是多少，只有等运行的时候才会知道

这是因为编译器把size也看作了本地变量，他一定要提前为所有的本地变量分配好内存（在函数刚进去的时候分配堆栈的大小）

---

对于一个指针，我们说他是const，有两种情况（对象是const还是指针是const）

* 第1种是这个指针作为一个变量，它是const，他只能存储一个地址，不能变动（但是该地址上的数据可以变动）
* 第2种是对象是一个const，你不可以通过指针去修改这个地方的值（实际上这个地方的值是可以修改的，只是不能通过这个指针修改）

<img src="https://s1.imagehub.cc/images/2024/11/27/0b30f5a5db5fb00e1154c5c416e9556a.png" alt="image 20220223192131279" style="zoom:50%;" />

这个(*p)是解引用

最后一行话*p，我觉得虽然没有加括号，但也应该是解引用的意思，

*第2个例子，我们其实更准确的来说，他加了const指的是你不可以通过指针P来修改指针P所指的地方，而不是说指针指到哪里哪里就是const*

---

还有一种情况不能进行修改，

const int ci = 3;

int* p;

p = &ci//✖ 默认指针是可以修改所指变量的值的，所以这样写也是错误的

---

![Snipaste 2024 11 28 16 23 55](https://s1.imagehub.cc/images/2024/11/28/13983c98b11e864294450fc16f285fff.png)

第一行对象是const，第三行指针是const

第二行是对象是const

==const写在星号的前面，对象是const==

==const写在星号的后面，指针是const==

---

下面一共有三句话，第一二句话只用选取一句就行了，就是说两句不要同时出现，

第3句输出的时候会输出，hello world，

因为之前我在想S不是一个数组首地址吗？为什么输出S可以输出整个数组？魏慕伦说cout他会尽量的去输出整个东西，如果你输出一个指针，那么cout会尽量输出指针所指内容的数据，而不是指针存放的地址

<img src="https://s1.imagehub.cc/images/2024/11/27/347f9d913f1bf2c7aeac427217fbe85a.png" alt="image 20220223200857061" style="zoom:50%;" />

那么我们来说第一二句写法的区别，第1句由于是一个常量，所以hello world会被放在内存中的常量区，也就是代码段

第2句他会被放在堆栈区，具体是对还是站，我也没太懂，老师总是把这两个词混在一起说，我觉得是栈，（对里面的内存是要申请的，比如，malloc或者new）

第2句他的hello world会被拷贝到这个位于堆栈的数组中

---

**使用const的原因**

有时候我们会像上面一样需要拷贝数据，但是拷贝数据的话它需要耗费内存和时间，所以我们希望如果直接传一个地址进去就好了，但是如果传地址进去，又怕被进行修改

如果是在对象前面加上const指的，就是整个对象的值都不可以被进行修改

```C++
const Currency currency(2,4);
```

但是这样很危险哎，也许你创建对象和写函数body的地方，并不在一个CPP文件里

万一函数的body里面写了，他要修改类的成员变量，而你在类的对象里面又不允许他修改，就会报错，所以一般我们不会这样一刀切为整个对象前面都加上const

<img src="https://s1.imagehub.cc/images/2024/11/27/747a0c1972283e949f4a99b87151913f.png" alt="image 20220223211657274" style="zoom:50%;" />

上面写了两个函数的定义，一个没加const，一个加了

在函数的前面加上const的就不会有那么一刀切的形式存在了，我们清楚的知道，==你不允许这个函数去修改成员变量的值==

==函数的const在声明和定义的地方都要写上==

<img src="https://s1.imagehub.cc/images/2024/11/27/320e55d8fb6167c23998482ba906ab94.png" alt="image 20220223211910070" style="zoom: 50%;" />



## 18.不可修改的对象（从这里开始速通）

下面这张图的以及相应解释我觉得逻辑不闭环。所以随便看吧

![Snipaste 2024 11 28 16 24 41](https://s1.imagehub.cc/images/2024/11/28/2a59570f47eab6ca5697f307519e2a7f.png)

首先在编译器里面，第一是public里面这样写函数是构成重载，第二是只会输出const那个f()

因为a（对象）是个const，所以指的是整个对象的值不能被修改。而加了const的那个函数指的是不可以通过函数去修改成员变量的值，所以a.f()会调用它

下面：成员变量是const时，必须在初始化列表的时候被初始化

![Snipaste 2024 11 28 16 25 17](https://s1.imagehub.cc/images/2024/11/28/3505ba017b8dab28a2abddc13e29cbe1.png)

image-20220224194223753.png"  style="zoom:50%;" 

下面：我们之前说const不能放进数组的[size]里，但是可以通过加static和枚举的方式

没学 不看了

### 留坑：枚举和static

![Snipaste 2024 11 28 16 25 55](https://s1.imagehub.cc/images/2024/11/28/2644ba799f5a727acc07a81bf8a1541e.png)

## 19.引用(reference)

访问对象的方式：

* 直接掌握对象
* 通过指针访问对象（指针的英文：pointer）
* 通过引用访问对象（reference）

<img src="https://s1.imagehub.cc/images/2024/11/27/e99f94f4202b997a67956662b38e5d39.png" alt="image 20220224201015312" style="zoom:50%;" />

* 引用定义时要一开始被初始化。r是c的引用

* 初始化的值必须是一个变量或者是一个可以做左值的东西

* r是c的别名，用r就是在用c，即一个东西的两个名字
* 参数和成员变量可以一开始不急着做初始化（对于参数，可以等调用它的时候再初始化，对于成员变量，可以等类创建对象的时候再初始化）
* 本地和全局变量做引用一开始要被初始化
* **引用很多时候被当成是一个类型使用，比如Int&是一个类型，int也是一个类型，有时函数的返回类型可以是int&。毕竟你看int&a =c；不就很像int a=c吗，类型+变量名 = 初始值**

---

const int&z = x;

“&”指的是z是x的别名，z和x一直绑在一起

const指的是通过z不能修改x

---

<img src="https://s1.imagehub.cc/images/2024/11/27/262ebd9c4308cb9a2ee13630abb0ef75.png" alt="image 20220224201710468" style="zoom:50%;" />

在f()里面对x做任何修改，外面的y也变了

---

传给引用的必须是个实实在在在的变量，有地址的变量

```C++
void func(int &);
```

上面这个写法是没有错的，如果他在括号里面写的是int &c，你可能还看得懂，你会说，无论我把谁传给这个函数至少C是那个东西的别名，我们现在只是没有给传入这个函数的东西起别名，但是我们会确保括号里的东西会指向你要传递函数的东西

```C++
func(i*3)
```

因为虽然三个a它是具有值的，但是它没有确切的地址存储，我们只是做运算而已。

---

<img src="https://s1.imagehub.cc/images/2024/11/28/8664ad52df5875515e437cbcee4a4d32.png" alt="image 20220224202629247" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/28/767497671a1c54b24552578574f524db.png" alt="image 20220224202352488" style="zoom:50%;" />

一个函数返回的结果是reference ，就可以做左值

即x变成16

没有任何人拿到X的reference，所以直接把16赋给函数，就是付给X，

---

**reference存在的意义**

为了让代码少点星号



---



* 没有指向引用的引用

  int &a = b;

  int &c = a;	//✖

* 没有指向引用的指针

  int&* p;	//✖指的是指针的类型是引用

<img src="https://s1.imagehub.cc/images/2024/11/28/7897cd030fd0436354a2d03d8ccd0f01.png" alt="image 20220224203809821" style="zoom:50%;" />

变量离谁近，就意味着变量是什么类型



## 20.向上造型

如果D是B的衍生类，

那么D的对象可以交给B的变量

D的指针可以交给B的指针

D的引用可以交给B的引用

<img src="https://s1.imagehub.cc/images/2024/11/28/ccaab7521dc96456e23d89fe9f8af021.png" alt="image 20220224210754860" style="zoom:50%;" />

如果B是A的子类，B的对象可以当做A的对象来看待

<img src="https://s1.imagehub.cc/images/2024/11/28/09ce390b80f3392cff71c8b82254c3f7.png" alt="image 20220224210950317" style="zoom:50%;" />

---

下面只是教你怎么样去探究类里面的大小呀，成员啊，（其实我没太理解，可以不用看这一小小节了）

<img src="https://s1.imagehub.cc/images/2024/11/28/e51ad25a958ff25fb7ae737ad6bde39a.png" alt="image 20220224211418110" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/28/c2f381324c9ea0ea17d72d828fcdefc0.png" alt="image 20220224211533673" style="zoom:50%;" />

倒数第四行是取地址符

倒数第二行和第四行

<img src="https://s1.imagehub.cc/images/2024/11/28/9ef0eb6a2e3bc351fefda959ffbca808.png" alt="image 20220224211813904" style="zoom:50%;" />

老师修改了

<img src="https://s1.imagehub.cc/images/2024/11/28/a668297205c5f6ade59cfd8aed7231df.png" alt="image 20220224211845319" style="zoom:50%;" />

---

为什么子类的对象可以被当作父类来看待，因为他们的数据结构是一样的，

我们光看下面这个大框框，他指的是B类，因为我们后来在B类里面又新增加了成员变量j，（i是父类的）

B作为子类继承了父类的i

如果一个指针既指向父类又指向子类，你可能觉得指针怎么能指向两个地址呢？其实并不影响的，无论指针指向父类还是指向子类，指的地址都一样，

### 子类可以被当做父类看待的原因

哪怕子类像现在这样新增加了成员变量，也不影响那个指针指向父类和子类的地址是一样的，因为即使子类新增加了变量，也不会破坏继承父类的那部分地质结构，它也会在别的地方去增加新的地址，==所以子类可以被当做父类看待==

<img src="https://s1.imagehub.cc/images/2024/11/28/92e776378a22e6bf394e972e0eb85076.png" alt="image 20220224212507546" style="zoom:50%;" />

---

如果你有一个子类的对象，被当做父类的对象来看待，这件事情叫upcast

<img src="https://s1.imagehub.cc/images/2024/11/28/a48b0b5fb578988ea09bdac14abbb20b.png" alt="image 20220224212824744" style="zoom:50%;" />

因为一般把父类画在上面，所以把子类当做父类看叫做Up(同样的也有down)

---

upcast是很安全的，比如这个父类叫做Person，子类叫做Student，

 Student是可以被看作是person的，因为student继承了person的一切东西，

但是如果把person看作是一个student也可以，但也许这个person不是students有一定的风险，student有的东西person没有

---

**造型&类型转换**

在C语言中我们把 cast叫做类型转换，比如把double转化成int

但是在C++里我们把cast叫做造型

在类型转换中，当你把double转换成int，那么那个数据它就丧失了double的一些特性，它已经完全的变成了int

但是在造型中它只是眼光的看待的变化，也就是说你把 Person看成student，并不是说person真的变成student，只是你这么看作



### 造型的应用

我们知道，manager作为employee的子类

如果你把 Manager的对象的地址给employee的指针，叫upcast

如果你把manager的对象给employee的引用也叫upcast

<img src="https://s1.imagehub.cc/images/2024/11/28/8b08bf0e411c9316c7b8b344e7a54843.png" alt="image 20220224213535779" style="zoom: 50%;" />

在employee中有两个print， Manager中有一个print，所以当时发生了在父类当中函数的隐藏，

这个指针EP是父类的类型，但是它指向的是子类的对象，但是你让指针去使用他指向的地方的成员函数，使用的却是**父类**的print

[![image 20220224213719708](https://s1.imagehub.cc/images/2024/11/28/a5e0ffe010069ac1f6d81ce463463971.md.png)](https://www.imagehub.cc/image/image-20220224213719708.CE2zYA)

## 21.多态性（polymorphism）

下面我们给出了三种图形，至于图形是什么图形，你光看画的图是什么形状就行了

这三个图形都具有相同的操作和数据，

操作的翻译分别是渲染 移动 改变大小（我们并不是说他们的方法做起来都一样，只不过说他们都具有这样的功能而已）

center是中心 它们都具有中心

<img src="https://s1.imagehub.cc/images/2024/11/28/ff86ff8448c5146af4faab3153b03601.png" alt="image 20220224220351408" style="zoom:50%;" />

如果这三个图形都具有一些相似的东西，逐个定义的话，总归是有点麻烦，我们采取的方法是可以先定义出一个图形，然后根据这个图形去定义其他图形，比如我们可以说椭圆是一种特殊的圆

正方形是一种特殊的矩形



![Snipaste 2024 11 28 16 26 36](https://s1.imagehub.cc/images/2024/11/28/a2b1bd275c01c8f6d431b93570bb3041.png)

square是正方形

在这里面我们定义出了一个shape作为类，具有center这样的数据，具有move render这样的方法，

对于其他的图形，我们只要用shape来定义就好了，和shape相同的地方就不用定义了，不同的地方可以再定义

但是其他形状的render（）要和shape的render（）有某种联系



代码 ：

![Snipaste 2024 11 28 16 26 58](https://s1.imagehub.cc/images/2024/11/28/ba32ab1066e494c2a7095e7da772595e.png)

**这个virtual的意思是说，如果子类里面也写了render函数，那么我们会默认父类的render和子类同名的render是有联系的**（virtual的真正含义下面也有）

（之前我们在给manager写print的时候并没有加virtual，所以当manager和employee的Print重名的时候，我们会默认他们没有关系）

那析构函数为什么会有virtual呢?子类的析构和父类的析构名字肯定不同，这个后面会解释

<img src="https://s1.imagehub.cc/images/2024/11/27/8340315ad6e3c41458ac1e4c709c0801.png" alt="image 20220224221436525" style="zoom:50%;" />

子类的virtual可加可不加（只要父类加了就行了，但是你在子类当中加这个词是个好习惯，这样别人不用去看你的父类，看你的子类也知道是有联系的）

<img src="https://s1.imagehub.cc/images/2024/11/27/dac3fff8d664586da1f772b6156b5f31.png" alt="image 20220224221727315" style="zoom:50%;" />

==一定要通过指针或者引用调用virtual才有可能发生多态性==

render是通用函数，对任何shape的子类都适用，也适用将来新出现的render的对象（那你会说万一我创建的这个shape的子类，并没有写自己的render函数呢，这只能说明这个子类，他没有自己的render函数，但是他是有render函数的）

我们做了eclipse的对象ell，ell.render是eclipse的render在render（成员函数是属于类的）

但是render(&ell)把ell的地址给指针，这个时候发生了upcast向上造型，把子类eclipse的对象当做父类shape的对象看待。

在render的函数里面，我们让指针所指的对象去做render这个事情。那么是谁去做render了？是ellipse。(按照之前的说法是shape)这是因为我们在里面加了virtual

**virtual的函数就在告诉别人对我这个函数的调用，如果是通过指针或者引用的话，你就不能相信他一定是什么类型，得要到运行的时候才能确定（ 动态绑定）这个指针所指的那个对象是什么类型，你再调那个类型的函数。**

它告诉编译器通过指针或引用去调用函数的时候，你不能直接在这里就写进来，要到调查函数要运行的时候。

所以你给他一个eclipse的对象，他就做eclipse的 render。你给他一个circle的对象，他就做circle的render。

p->render他对任何shape的子类都是适用的。

这就叫做多态性，在这里面P是多态的。P是多态对象。P里面指的什么类型的对象，通过P做的动作就是那个类型的对象做的。

P指的是谁，就变成谁的形态

:tropical_fish:**:多态建立在两个基础上。**
第一upcast。拿一个指针对象，当做父类的对象。(Eclipse被当做sheap来看待。)
第二叫做动态绑定。绑定指的是当我调用函数的时候，应该去调用哪个函数。
静态绑定:我调用的函数在编译的时候是确定的。
动态绑定:要到运行的时候才知道要调用哪个函数。

![Snipaste 2024 11 28 16 27 34](https://s1.imagehub.cc/images/2024/11/28/4ffa319be326cb4f138f6501d3c22e27.png)polymorphism:多态性

dynamic bingding：动态绑定

---

**多态性的实现**

怎么动态绑定呢？下一节看 但我跳过了

## 22.多态的实现

就是当你有一个类,类里面的一些函数，你加上了virtual，假设类叫A，对象是A a；那么把a的地址给指针，指针解引用发现竟然不是值，而是一个地址。

地址即指针，这个指针叫做vptr，指针指向vtable，里面存放着所有virtual函数的地址

（下面的一大段代码都是为了验证这句话）



我们现在要验证一个事情，任何一个类，如果他的成员函数哪怕只有一个是虚函数

这个类的对象就会比正常的大一点

（下面的区分取地址符和引用符）



[![Snipaste 2024 11 28 16 28 05](https://s1.imagehub.cc/images/2024/11/28/407cb6058fc1474212a3306315782d34.md.png)](https://www.imagehub.cc/image/Snipaste-2024-11-28-16-28-05.CE5WLG)

<img src="https://s1.imagehub.cc/images/2024/11/27/974219a9de792c6dc34018a748348ecc.png" alt="image 20220225120409254" style="zoom:50%;" />

代码修改：p++；

<img src="https://s1.imagehub.cc/images/2024/11/27/ca67499baad0beb22ee6a96f7d43d18c.png" alt="image 20220225120558475" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/27/35eed539c4c312322d4696cfbd7def6a.png" alt="image 20220225120628618" style="zoom:50%;" />

为什么P++，输出新地址的值就是10，这很怪诶

如果把下面这个大方括号比作对象，那么对象的上面一部分不知道是什么东西，下面一部分存放的才是变量，

这就是为什么指向对象的指针，如果你直接输出解引用的值是一堆，不知道是什么的东西

但是你把指针指向对象的别的地方向下移，就发现可以输出变量了

<img src="https://s1.imagehub.cc/images/2024/11/27/0e60ed48f29befa8d6b81fadf92061a8.png" alt="image 20220225144857610" style="zoom:50%;" />

那么对象上面那一部分是什么东西呢？

![Snipaste 2024 11 28 16 29 11](https://s1.imagehub.cc/images/2024/11/28/12a8e3f379f013d717712827ee92d651.png)

那个东西是个指针，叫做vptr

所有有virtual类的对象就会自动加上指针，叫vptr，指向一张表，叫做vtable，vtable里是所有virtual函数的地址。vtable是类的，所以类的所有对象的指针指向的地方一样，指针的值一样

这就是为什么当你解引用P的时候会出现一个地址，因为在这个地方它就是一个指针，它存放的是 vtable的地址 

<img src="https://s1.imagehub.cc/images/2024/11/27/d5c2b7fe482d7542eef359e65364075d.png" alt="image 20220225133344014" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/27/07fc5997bb6641ae20c5b89e83fe0367.png" alt="image 20220225133451397" style="zoom:50%;" />

注意哦 p和q不一样 但是星p和星q一样 说明对象创建出来的某个地方的东西一样



我们之前说对象的一个部分存的不是地址吗？所以现在我们把这个地址访问一下，看看里面存储的会是什么，（当然了，你自己要提前清楚，带有virtual函数的地址）

但是这里重点教你是怎么去访问那个地址的地方。学方法。

<img src="https://s1.imagehub.cc/images/2024/11/27/218d95514b7209a8a46d5b414b938412.png" alt="image 20220225165719958" style="zoom:50%;" />

蓝线勾画的那一句，*p是解引用，解引用出来是一个地址，由于是个地址，又可以作为地址交给指针x，现在指针x指向vtable的第一行

至于输出x，wml说了，C++输出指针会倾向于输出指针所指的值。

所以输出x是输出vatble第一行的值，又是个地址

---

![Snipaste 2024 11 28 16 29 38](https://s1.imagehub.cc/images/2024/11/28/7a1529fde75d808aa2db1357b324bbd8.png)

上面的是shape类，下面的是eilipse类，我们知道ellipse是shape的子类，但是我想在叙述结论之前先强调一点vtable，它是一个类都用的vtable，所以父类和子类用的vtable是不一样的

以及这里面我们把constructor简称为dtor

在shape类里面我们可以看到它有三个virtual函数，所以在vtable里面我们也指向了三个函数，这里面有两个颜色，我将果绿色称为黄色，另一个颜色我就称为绿色来区分

其次我们可以在elilpse的vtable里，看到有两个颜色是绿色的，说明都是继承自自己的，并且这两个颜色前面也用解析符表明了是自己类，注意了，这时候可不要把render搞成是父类的，我们之间的virtual只说子类的render和父类的render是有联系的，并不是一个render，但是他们还是各自的render

![Snipaste 2024 11 28 16 30 14](https://s1.imagehub.cc/images/2024/11/28/d79e6adec2323a742be29fd18775a504.png)

​	

###  多态的秘密

<img src="https://s1.imagehub.cc/images/2024/11/27/70f61cb8b783c27776a4fcac26354bf1.png" alt="image 20220225171310307" style="zoom:50%;" />

这个是之前的函数，我们可以在倒数第3行里面看到我们把elilper的对象ell传进了render，

倒数第3行，虽然我们还没有开始讲原理，但我们一定要清楚结果，按理说你把ell传给shape *p的时候发生了向上造型，出来的应该是employee的render函数，但是最后调用的是ellipse的render函数

**那么动态绑定是怎么发生的呢？**

在render函数里面，我们首先发生了向上造型，把子类的对象看作是父类，

在同时的时候你把ell的地址给了p，并且你在render函数里面要求让P所指的对象调用render函数，p会根据ell（对象）的地址去找对象第1个位置的东西（vtable的地址），在vtable里地址不断的加加（由第一个virtual函数加到render函数的地址）他就找到了子类的render函数



这种运行方式他看起来很智能，能够区分是哪个类的对象，要求做render函数，但其实它也就是机械的查找地址的功能

---

下面是一个新的类，叫做circle，但是它是继承ellipse的，由于ellipse继承自shape，所以circle也是shape的子类，也可以发生向上造型

![Snipaste 2024 11 28 16 30 39](https://s1.imagehub.cc/images/2024/11/28/4745c919318daea60b28d01cafd97fb5.png)

在circle里面他新加了一个函数叫radius，新加了一个变量叫area

<img src="https://s1.imagehub.cc/images/2024/11/27/b4041d0ae20697d78b25ae51b46b6f2e.png" alt="image 20220225172339816" style="zoom:50%;" />

现在我们新创建了两个对象，对象后面的括号就是初始化，这个是要看类的具体的要求，与我们现在要探究的问题没有一点关系，我们现在重点关注的是我们知道circle他新加入了一些东西，所以他肯定要比ellipse大的，

那么把大的赋值给小的会发生什么呢？（对象是可以赋值的，就跟一个变量赋值给另一个变量，就是把值给它）

![Snipaste 2024 11 28 16 31 04](https://s1.imagehub.cc/images/2024/11/28/5a8909aee33cee21563e3bfe3d86c903.png)

<img src="https://s1.imagehub.cc/images/2024/11/27/ef95203e0ef23eba46005fb49a680c66.png" alt="image 20220225172708656" style="zoom:50%;" />

在p->f()里调用的是B的f()

在a,f()里调用的是A的还是B的f()？



--是A的

哪怕b赋值给a，再通过指针去调用virtual，也还是调用A

<img src="https://s1.imagehub.cc/images/2024/11/27/6bcbdd7bcd0915e98f40d6c642e76dbe.png" alt="image 20220225173037060" style="zoom:50%;" />

这是因为只是把b的值给了a，但a还是a

:fish:真相在于：

<img src="https://s1.imagehub.cc/images/2024/11/27/f4b5fc675ef6f4c851216af621c00ea5.png" alt="image 20220225173218568" style="zoom:50%;" />

比如把ellipse赋值给shape，vptr并不会赋值给shape，vptr不传递，shape的vptr没变

验证：

<img src="https://s1.imagehub.cc/images/2024/11/27/3d685b45a534b12a39405fc7c96ca4d9.png" alt="image 20220225173333399" style="zoom:50%;" />

这样输出了B的f()，内部发生了什么呢？

把b的vptr存储的地址放到了a里存储vptr地址的地方，a的vptr指向b的vtable

<img src="https://s1.imagehub.cc/images/2024/11/27/f3ee98fc89d1eb4cfa6adccca7594757.png" alt="image 20220225174124497" style="zoom:33%;" />

![Snipaste 2024 11 28 16 31 36](https://s1.imagehub.cc/images/2024/11/28/30f29a6b246f5c0efb0288ced3002b6c.png)

所以我们现在可以确定用这种方式可以调用B的F函数，但是在B的F函数里面，我们第1个是要cout要一串字符串，第2个是要输出J，而在a里是没有变量j的，所以它找到了a里的另一块内存假装是j输出给你看

---

之前我们抛出一个问题，为什么distractor也要是virtual呢？

<img src="https://s1.imagehub.cc/images/2024/11/27/876e2d80228616308bfbb9c4bbc2295b.png" alt="image 20220225175435135" style="zoom:50%;" />

在这里面我们新开辟了一块内存，是ellipse的对象，p指向它

然后delete p要调用析构函数，如果你的析构函数没有加virtual，那么它会直接调用 Sheap的析构函数，

所以要加

**一旦你的类里面有一个函数是virtue，那么你的析构函数都要加virtual来避免风险**



### overrinding

<img src="https://s1.imagehub.cc/images/2024/11/27/818e936a81d12dd810a9fc3a49bf1d45.png" alt="image 20220225180104366" style="zoom:50%;" />

父类和子类，如果都有函数是virtual的，名字相同参数相同，构成一个关系叫overriding，中文叫改写，覆盖

(他和重载overload的区别是他给两个函数都加了virtual)

如果你想在derived class里调用父类的func()

就写Base::func()



假如B继承了A，在A和B里都有一个函数叫F，在A里定义F的返回类型是**指针**或者**引用**，那么在B里调用F（），也会返回B类型的指针或者引用

<img src="https://s1.imagehub.cc/images/2024/11/27/3e83364376bb4ce257f5da9f474cc141.png" alt="image 20220225180825792" style="zoom:50%;" />

最后一行，不能返回子类对象本身



## 23.引用再研究(涉及了不少const)

如果你的引用是一个本地变量或者全局变量，那么一开始的时候就应该赋初始值

但是如果你的引用是一个成员变量或者函数的参数，是没有办法一开始捆绑值的

<img src="https://s1.imagehub.cc/images/2024/11/27/e81885e69f1dae8f18449f58d55a9b61.png" alt="image 20220225203021014" style="zoom:50%;" />

这个图里面有些小细节，我真的快思考的要死了，还好想明白了，	在X类里面，我们有两个有关引用的成员， My，一个是成员函数，也就是构造函数，虽然我们没有办法，像本地变量一样直接给他们赋变量，但是我们**一定**要在构造函数初始化列表的时候给成员变量初始化

那你可能会说那构造函数在哪里初始化呢？构造函数是在创建对象的时候初始化，所以到时候自然有人帮构造函数初始化，但是成员变量谁能管他呢，所以只好把它挂在构造函数的旁边进行初始化

**初始化与赋值的不同**

我们在说本地变量和全局变量声明的时候就初始化指的是int &a =c，声明的时候一定是有变量的类型的，如果你写成int &a，a = c，这就叫做赋值了，虽然我现在没有完全了解到赋值和初始化的区别，但是你给引用进行初始化的时候，绝对不能分两步写（但是你可以这样写，int &a = c;a = e，这样相当于直接c = e）

同样的，我们在构造函数的初始化列表里面对成员变量进行初始化的时候，我们的初始化是指在构造函数后面加上一个冒号，然后加上成员变量里面加上初始值，

如果你是这样写X::X(int &a) {m_y = c；}

这样子的写法与图中写法的区别是，这样子的写法你是把c赋值给m_y所捆绑的变量（虽然m_y并没有真的捆绑，这样写也会报错）

那你如果直接列表初始化的话，我们就是直接把一个变量给my作为初始化

这个a是什么呢？它是局部变量吗，是的，但是它与构造函数初始化里面的a绝对不是一个a，当然这是我自己的看法，但我觉得是正确的，因为你在调用构造函数的时候，你完全可以给好几个东西都传初始值，不是说只传一个初始值进去把这个初始值给构造函数后面的一堆要初始化的东西

**综上，如果成员变量你不再构造函数，后面列表初始化会报错，注意不是warnings，而是直接errors**



###  返回本地变量全局变量

<img src="https://s1.imagehub.cc/images/2024/11/27/3cede0135daa51baf9ec0f4c0cc485ef.png" alt="image 20220225204808785" style="zoom:80%;" />

一般的来说，函数是可以返回局部变量的。

 局部变量的作用域只在函数内部，在函数返回后，局部变量的内存已经释放了。因此，如果函数返回的是局部变量的值，**不涉及地址**，程序不会出错。

但是如果返回的是局部变量的地址（返回类型是指针或者引用）的话，程序运行后会出错。因为函数只是把指针赋值后返回了，但是指针指向的内容已经被释放了，这样指针指向的内容就是不可预料的内容，调用就会出错。准确的来说，函数不能通过返回指向栈内存的指针(注意这里指的是栈，返回指向堆内存的指针是可以的）

注意这里的一些细节，可不可以返回类型是指针或者引用，可以  ，但是绝对不可以把本地变量也就是局部变量的地址复制给他们

**returning reference**

<img src="https://s1.imagehub.cc/images/2024/11/27/e237aebab9901a175697dbf5b5187d49.png" alt="image 20220225204218713" style="zoom:50%;" />

注意这个符号“&”，这个符号他有的时候是取地址符，有的时候是引用符号，一定要分开，在这里面它就是一个引用符号

在这里面我们返回的是数组的一个元素，也就是我们把数组这个元素作为变量返回了，并且这个变量它不是本地变量，是全局变量，

所以这个程序成立的条件有两个，第一是我们返回的是一个变量，第二是，我们返回的不是本地变量

**应用：**

<img src="https://s1.imagehub.cc/images/2024/11/27/28d608be196175a88b54817154622560.png" alt="image 20220225205452728" style="zoom:33%;" />

在倒数第三行我们把double&赋值给double，看上去类型不对，但是我们这里是把double&绑定的变量赋给double，就没问题了

注意在这里看题的时候，一定要把函数看成整体，看到一个函数表面上它是一个函数，实际上它已经是一个结果，返回结果的那个结果，所以看到subscript（12）实际上应该看成double&类型，它绑着myarray[12]

倒数第二行是 	myarray[3] = 34.5

我觉得可以把引用符看作一个很无私的人，他为自己绑定的那个变量保驾护航，一旦有人需要用到那个变量，他一定退出去让别人使用那个变量，但是他也是很专一的人，他会一直绑定这个变量



---

**const in Function Arguments**（函数参数中的const）

如果你要给函数传一个对象，那么对象很大该怎么办呢？不是很费事吗

所以可以送指针进去

但是传入地址指针也有可能修改这个地址的值，（有不懂的可以去看公众号）

所以我们推荐在指针前面加上const，他可以保证你把地址送进来，我不会通过我这个指针去修改你的地址上的东西

Person( const int*b)

但是在C++里我们经常用&这个符号，这是因为有了这个符号就不用写星号了，看上去比较简洁（当然这个符号还有引用传递的意思。只不过我们这里面需要的并不是引用传递，而是需要保证传进来的值的安全）

写const的写法其实是非常常见的，因为他很能保证安全

---

**temporary values are const**(临时变量是const)

<img src="https://s1.imagehub.cc/images/2024/11/27/4d92cd05354efd5e813063e001f2573c.png" alt="image 20220225215331795" style="zoom:50%;" />

之前我们说不能把i*3传给int &，有好几种解释，其中一种解释是，i✖3是临时变量，编译器对于临时变量的处理是会生成一个const int来存储这个值，而当你把const int这个类型的值赋值给非const的int &时肯定是类型不匹配的

那么你会说如果我让一个const int&来接收i×3呢？

<img src="https://s1.imagehub.cc/images/2024/11/27/e30a4d0ac84fe58ca80321d1b5554a20.png" alt="image 20220225215548808" style="zoom:50%;" />

成功了 输出9

---

**const in Function returns**（函数的返回类型有const）

说一个与小标题无关的东西，下面的第2行蓝线返回的是对象，这个操作是允许的，

第3行蓝线看着很奇怪，但是由于F函数返回的是一个对象，所以f().i可以看成是a.i，又因为i是public，所以对象可以直接使用成员变量，

<img src="https://s1.imagehub.cc/images/2024/11/27/136e093d1d91fa448dc09b69635143cc.png" alt="image 20220225220132707" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/27/2a694ddf75f8657effbd2782490c7cb5.png" alt="image 20220225220428415" style="zoom:50%;" />

如果我们给函数前面加上一个const，这意味着什么呢？**意味着函数的返回类型，也就是对象不可以被修改**

下面的图是之前某个课时的内容，当时我们把cost加的位置是在名字及括号的后面，表示的是不允许函数去修改成员变量的值

<img src="https://s1.imagehub.cc/images/2024/11/27/d8a97a5965dea97e809e75a4d65c48a6.png" alt="image 20220225220624104" style="zoom:50%;" />

## 24.拷贝构造

可以预测一波，拷贝讲的与函数传参有关

现在举个函数栗子

<img src="https://s1.imagehub.cc/images/2024/11/27/2221bcc2372932b2e3b28372c4467f4e.png" alt="image 20220301151614082" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/27/62766db057993647926bb229cf742652.png" alt="image 20220301151807984" style="zoom:67%;" />

这个Howmany f()的Howmany是返回类型，指的是返回类型是对象

整个程序解析：可以看到在程序第四行，有个全局变量objectcount，在Howmany类里，每构造一个Howmany的对象，objectcount++，同时调用print函数，print函数会先输出你传入给它的值，其次会输出objectcount的值，而析构函数中objectcount--；

也就是说他们计算objectcount数量的。

在main里，我们会先用print输出objectcount的值，（当然也是在调用构造函数之后）

其次我们会进行一个f函数的操作，然后会再调用print输出objectcount的值

那么f()函数进行什么操作了？感觉没干什么，就算纯cout了



那么这个函数的目的是啥？现在还没看console，所以浅猜一下，就是看看传参会不会生成新的对象（如果生成了就会调用构造函数，objectcount++）

下面是console的内容（比较多 你可以自己找东西对照）

![Snipaste 2024 11 28 16 33 00](https://s1.imagehub.cc/images/2024/11/28/623e564f472d13b2c93d0dab341ba61b.png)

首先是创建对象，然后会objectcount++，第一句（右边边框的第二句）输出成功，其次在左边是h.print，然后再输出1，没什么问题。

在f函数中，我们看到 x argument inside f()，这时的objectcount还是1，但是你会发现调用了析构函数，很奇怪（在f()里），在main()我们的print语句应该输出的是after call to f()，所以上面那句析构的的确确是在函数发生的，并且确实减掉了一个objectcount，留个**？**在这里

其次是出作用域，但是却调用了两次析构函数，也许是h和h2?



💡我们来看之前留问号的地方，当时只调用了一次析构，而在这之前只有一次调用了构造函数（由console得知），难道是h被析构掉了？我们知道不太 可能，h应该在花括号作用域结束的时候才被析构。我们可以猜测，**在f()里，一定构造了一个东西出来，只不过没有通过构造函数，但是它可以调用析构函数**，哦对了，你有没有反应过来h2的被析构之前，没有调用构造函数诶，h2的构造也绕过了构造函数



![Snipaste 2024 11 28 16 33 30](https://s1.imagehub.cc/images/2024/11/28/401f537616d937bab3b9866951437b11.png)

这个和之前的唯一区别是没有再析构一次（所以会比之前大一）

但是即使是这么明朗的赋值，貌似h2的创建也没有调用构造函数

 这里可以看到值是-1，值是负1，你可以理解为账没有做平，做平的话就会是0，零是指构造函数每次被调用，object count+1而析构函数调用object count-1，所以如果一个东西的构造函数和析构函数被正常调用，那么一定是0，

这里面是-1，是因为h2的构造函数并没有被调用，

所以我们要探寻的是为什么没有被调用？是因为赋值给他是h的关系吗？



首先要知道，如果有一个这样的构造函数Howmany(int i){objectcount++}; 也就是需要一个整数作为参数的构造函数（构造函数允许重载，也就是说，哪怕你有一个这样需要这个参数的构造函数，它也同时允许一个不需要任何参数的构造函数）当你这样写的时候，Howmany h2（2）；这个写法就是创建一个对象很正常，我们也会调用这个需要整形参数的构造函数，但如果你用这种写法，它也会调用这个函数，Howmany h2 =2；看起来比较匪夷所思，因为我们知道初始化和赋值是不一样的，但是在创建对象的时候，这两种写法真的是一模一样的。**这一段主要是为了说明这两种写法是一样的**，但同时这一段还提供了另一个信息，就是并不是说你H2出来就不会调用构造函数，如果你有一个这样的构造函数，并给hr一个这样的写法去出使话，他也会调用这样的构造函数，并且在count会加加，也就是说最后的数字会是0

那如果我们就是想像之前的写法一样，howmany h2 = h;怎么在这种写法的同时去调用构造函数呢？利用上一段的推演我们可以得出，如果你有一个构造函数，它是需要一个对象作为参数，那么也能调用这样的构造函数。Howmany(const Howmany& o){objectcount++;print("Howmany(HM)")};

上面是一个构造函数，如果你存在一个接收Howmany类的一个对象的构造，那么你在用howmany h2 = h写法的时候，也是可以给h2调用构造函数的，

<img src="https://s1.imagehub.cc/images/2024/11/27/803738a5d00c2f8f50a9d5d533a7d7bb.png" alt="image 20220304121242062" style="zoom:50%;" />

看第三行



那么我们已经理解了，用这种写法howmany h2 = h的同时怎么去要用h2的构造函数，但是我们之前还写了一个写法是这样的，howmany h2 = f(h),当时貌似也是没有调用出构造函数，只有析构函数，我们把f函数的原文贴在下面，

<img src="https://s1.imagehub.cc/images/2024/11/27/83c2721018798f27b8c7a8011b1bbd94.png" alt="image 20220304122049090" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/27/a861f4d26545c6c230a0cce7a4f9a47a.png" alt="image 20220304121446546" style="zoom:50%;" />

<img src="https://s1.imagehub.cc/images/2024/11/27/b628bec04ac2ccf7cd6ab91fce1f7ce7.png" alt="image 20220304122104532" style="zoom:50%;" />

上面是当时的原文，这里面只调用了一次构造函数（+1），但是析构三次（-3），所以最后的值是-2，

调的构造函数是h对象创建的时候调用的，析构的分别是x(h里的形参)，h，h2

---

Howmany(const Howmany& o){objectcount++;print("Howmany(HM)")};

但当我们有上面这样一个构造函数，

<img src="https://s1.imagehub.cc/images/2024/11/27/b2e4c4f9fd71627ad953ad068b971db7.png" alt="image 20220304122316825" style="zoom:50%;" />

哪怕你还是像之前这样写，看看会有怎样的变化，

<img src="https://s1.imagehub.cc/images/2024/11/27/c0d57168f9350e830662ba09315962dd.png" alt="image 20220304121633606" style="zoom:50%;" />

可以看到上面的账做平了，说明调用构造函数和析构函数的次数是相等的，h自不必说，objectcount+1，然后是x被调用，h2被调用。这也是为什么最高的时候objectcount会有3

可以看到构造函数能被多调用两次，完全是凭借之前我们写的一个构造函数的原型，

Howmany(const Howmany& o){objectcount++;print("Howmany(HM)")};

这个函数的特点是它允许传howmany这个类的对象进去，

而且x，h2确实符合这个条件

---

:fishing_pole_and_fish::

**如果你有一个构造函数，构造函数的参数是自己类型的reference，构造函数就可以在做它这种类型的初始化的时候被调用**

